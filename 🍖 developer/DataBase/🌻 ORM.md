
[[JDBC]]
**ORM (Object-Relational Mapping)** — это метод, который позволяет разработчикам работать с базами данных на уровне объектов, а не на уровне строк SQL. С помощью ORM можно отображать структуры базы данных (например, таблицы) в объекты и наоборот. Это упрощает взаимодействие между приложением и базой данных, позволяя работать с данными как с объектами, а не вручную писать SQL-запросы.

### Что такое ORM?

ORM — это технология, которая автоматически сопоставляет реляционные таблицы с объектами классов в программировании. Основная цель ORM заключается в том, чтобы устранить разрыв между объектно-ориентированным программированием и реляционными базами данных. ORM автоматически преобразует данные из реляционной базы данных (в виде строк, столбцов и связей) в объекты, с которыми разработчики могут работать в коде.

### Как работает ORM?

1. **Модели**: В ORM каждая таблица базы данных отображается в класс, а каждая строка таблицы становится объектом этого класса.
    
    - Например, таблица `users` может быть представлена как класс `User` в коде, а каждая запись в таблице — как отдельный объект `User`.
2. **Маппинг (сопоставление)**: ORM сопоставляет поля объектов с колонками таблиц, а методы класса с операциями над этими данными. Это позволяет автоматизировать создание SQL-запросов (вставку, обновление, удаление, выборку данных) без явного написания SQL.
    
3. **Запросы**: ORM-фреймворк преобразует операции с объектами в SQL-запросы. Например, добавление нового объекта в коде становится SQL-запросом для вставки записи в базу данных.
    
4. **Связи между таблицами**: ORM позволяет легко работать с отношениями между таблицами (например, "один ко многим", "многие ко многим") с помощью объектных связей. Это делает работу с сложными структурами данных более удобной.
    

### Пример работы ORM:

#### Допустим, у нас есть таблица `users` в базе данных:

sql

Копировать код

`CREATE TABLE users (     id INT PRIMARY KEY,     username VARCHAR(255),     email VARCHAR(255) );`

С ORM ты можешь представить эту таблицу как класс:

java

Копировать код

`public class User {     private int id;     private String username;     private String email;      // Геттеры и сеттеры     public int getId() { return id; }     public void setId(int id) { this.id = id; }      public String getUsername() { return username; }     public void setUsername(String username) { this.username = username; }      public String getEmail() { return email; }     public void setEmail(String email) { this.email = email; } }`

Теперь ORM сопоставит этот класс с таблицей `users`, и ты сможешь выполнять операции с объектами `User`, не пиша SQL-запросы.

#### Пример с использованием популярного ORM-фреймворка (например, Hibernate):

- Чтобы сохранить нового пользователя в базе данных, ты можешь просто создать объект `User` и вызвать метод сохранения:

java

Копировать код

`User user = new User(); user.setUsername("john_doe"); user.setEmail("john@example.com");  session.save(user); // Hibernate сам выполнит SQL-запрос для вставки данных`

ORM автоматически преобразует этот код в SQL-запрос:

sql

Копировать код

`INSERT INTO users (username, email) VALUES ('john_doe', 'john@example.com');`

#### Для выборки данных из базы:

java

Копировать код

`User user = session.get(User.class, 1); // Получаем пользователя с id=1 System.out.println(user.getUsername());`

ORM сгенерирует SQL-запрос:

sql

Копировать код

`SELECT * FROM users WHERE id = 1;`

### Основные преимущества ORM:

1. **Сокращение количества кода**:
    
    - ORM значительно сокращает количество кода, необходимого для выполнения операций с базой данных. Вместо того чтобы писать SQL-запросы вручную, ты работаешь с объектами.
2. **Поддержка абстракции**:
    
    - ORM скрывает детали взаимодействия с базой данных. Ты можешь работать с объектами и методами без необходимости писать сложные SQL-запросы.
3. **Повышение портируемости**:
    
    - ORM делает приложение более независимым от конкретной базы данных, так как SQL-запросы генерируются автоматически. Это позволяет легко переключаться между различными базами данных.
4. **Управление связями**:
    
    - ORM упрощает работу со сложными связями между таблицами, такими как "один ко многим", "многие ко многим". Эти связи можно легко реализовать на уровне объектов.
5. **Кэширование**:
    
    - ORM-фреймворки, такие как Hibernate, поддерживают кэширование, что помогает повысить производительность при работе с большими объёмами данных.

### Популярные ORM-фреймворки:

1. **Hibernate**:[[JDBC]]
    
    - Самый популярный ORM-фреймворк для Java. Он обеспечивает гибкие возможности для работы с базами данных и поддерживает множество видов отношений между объектами (One-to-One, One-to-Many, Many-to-Many).
2. **JPA (Java Persistence API)**:
    
    - Это стандартная спецификация для ORM в Java. Многие фреймворки, включая Hibernate, реализуют JPA. JPA предоставляет единый интерфейс для взаимодействия с различными базами данных.
3. **EclipseLink**:
    
    - Одна из реализаций JPA, которая предоставляет аналогичные возможности, как и Hibernate.
4. **Spring Data JPA**:
    
    - Это часть фреймворка Spring, которая упрощает использование JPA и делает работу с базами данных ещё более удобной за счёт автоматизации репозиториев и запросов.


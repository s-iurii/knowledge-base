
# Маштобирование

Master-slave replication
Master-Master Replication
Шардирование
Партицирование


# index DB

Кластерные и некластерные индексы — это два разных типа индексов, которые используются для ускорения доступа к данным в реляционных базах данных. Оба типа индексов применяются для повышения производительности при выполнении запросов, но они работают по-разному и имеют свои особенности.

### 1. **Кластерный индекс (Clustered Index)**

**Кластерный индекс** организует физический порядок строк таблицы на диске в соответствии с индексируемыми значениями. Это означает, что данные в таблице физически отсортированы в соответствии с этим индексом.

#### Характеристики кластерного индекса:

- **Один кластерный индекс на таблицу**: Поскольку он сортирует и физически организует данные, в таблице может быть только один кластерный индекс.
    
- **Организация данных на уровне таблицы**: В таблице с кластерным индексом данные хранятся в порядке, соответствующем значению индексируемого столбца.
    
- **Быстрый доступ к данным**: Кластерный индекс делает поиск данных быстрее, поскольку данные физически организованы. Если запрос использует кластерный индекс, база данных может быстро найти данные, избегая дополнительных операций поиска.
    
- **Пример**: Если на таблице пользователей есть кластерный индекс по полю `id`, то строки в таблице будут физически отсортированы по значению `id`.
    

#### Пример кластерного индекса:

`CREATE CLUSTERED INDEX idx_user_id ON users(id);`

#### Когда использовать кластерный индекс:

- Для полей, которые часто используются для поиска и сортировки (например, первичные ключи).
- Если данные часто извлекаются в определённом порядке (например, по дате).

---

### 2. **Некластерный индекс (Non-Clustered Index)**

**Некластерный индекс** создаёт отдельную структуру данных (индекс) для столбцов, в которой хранятся ссылки на фактические строки таблицы. Некластерный индекс не изменяет физический порядок строк в таблице.

#### Характеристики некластерного индекса:

- **Множество некластерных индексов**: В отличие от кластерного индекса, на одну таблицу можно создать несколько некластерных индексов. Это позволяет создавать индексы для разных колонок, которые могут использоваться для разных запросов.
    
- **Отдельная структура**: Некластерный индекс хранится отдельно от данных таблицы и содержит ссылки на физическое местоположение строк (например, на страницы данных).
    
- **Меньше эффективен при чтении**: Для поиска данных по некластерному индексу может потребоваться больше шагов, так как сначала выполняется поиск по индексу, а затем доступ к данным через ссылки.
    

#### Пример некластерного индекса:

`CREATE NONCLUSTERED INDEX idx_user_email ON users(email);`

#### Когда использовать некластерный индекс:

- Для столбцов, которые часто используются в условиях фильтрации (`WHERE`), но не сортируют строки в таблице.
- Для поддержки вторичных запросов (например, по электронной почте, имени или дате рождения).

---

### Основные различия между кластерными и некластерными индексами:

|**Кластерный индекс**|**Некластерный индекс**|
|---|---|
|Физически организует данные в таблице на диске.|Не изменяет физический порядок строк.|
|Один на таблицу.|Может быть несколько индексов на таблицу.|
|Быстрый доступ к данным, поскольку данные отсортированы в соответствии с индексом.|Менее эффективен при чтении, так как требует перехода по ссылкам для поиска данных.|
|Применим для столбцов, которые часто используются для сортировки и поиска.|Подходит для столбцов, которые часто используются для фильтрации в условиях запроса.|






# Оптимизация запроса
## EXPLAIN
Команда **`EXPLAIN`** в SQL используется для анализа плана выполнения запроса. Она показывает, как база данных собирается выполнять запрос и какие шаги будут предприняты для его обработки. Это полезно для выявления узких мест в производительности, а также для понимания того, как можно оптимизировать запросы.

### Основные моменты о `EXPLAIN`:

1. **Показывает план выполнения запроса**: Как таблицы будут соединяться, какие индексы будут использоваться, порядок операций и многое другое.
2. **Позволяет проанализировать работу оптимизатора запросов**: Оптимизатор решает, как наилучшим образом выполнить запрос, и вывод `EXPLAIN` помогает понять его логику.

### Пример использования `EXPLAIN`:

Предположим, у нас есть следующий запрос:

sql

Копировать код

`SELECT u.user_name, s.service_name FROM users u JOIN cars c ON u.user_id = c.user_id JOIN services s ON c.car_id = s.car_id;`

Для анализа выполнения этого запроса мы можем использовать команду `EXPLAIN`:

sql

Копировать код

`EXPLAIN SELECT u.user_name, s.service_name FROM users u JOIN cars c ON u.user_id = c.user_id JOIN services s ON c.car_id = s.car_id;`

Результат покажет шаги, которые выполнит база данных.

### Что показывает `EXPLAIN`:

Вывод команды `EXPLAIN` может немного отличаться в зависимости от конкретной базы данных, но основные компоненты схожи. Вот ключевые поля, которые ты увидишь:

|Поле|Описание|
|---|---|
|**id**|Уникальный идентификатор для каждого шага плана выполнения запроса.|
|**select_type**|Тип запроса: простое SELECT, подзапрос, деривация и т.д.|
|**table**|Таблица, к которой применяется текущий шаг плана.|
|**type**|Тип соединения. Это одно из самых важных полей, которое показывает, как таблицы соединяются.|
|**possible_keys**|Индексы, которые могут быть использованы для этого запроса.|
|**key**|Фактический индекс, который будет использоваться для соединения.|
|**key_len**|Длина используемого индекса.|
|**ref**|Колонка или выражение, используемое для поиска значений в индексе.|
|**rows**|Примерное количество строк, которое будет рассмотрено на каждом этапе выполнения.|
|**extra**|Дополнительная информация, такая как "Using index", "Using temporary" и другие комментарии.|

### Важные моменты плана выполнения:

1. **Тип соединения (`type`)** Это одно из самых важных полей. Чем лучше тип соединения, тем быстрее запрос будет выполняться. Вот основные типы соединений:
    
    - **`system`**: Таблица состоит только из одной строки (очень редко).
    - **`const`**: Таблица имеет только одну строку, которую можно найти напрямую через индекс или первичный ключ. Это самый быстрый тип соединения.
    - **`eq_ref`**: Для каждой строки из предыдущей таблицы выполняется одно точное сопоставление. Это происходит, когда используется уникальный индекс (например, первичный ключ).
    - **`ref`**: Для каждой строки из предыдущей таблицы выполняется поиск по индексу, но может быть несколько соответствий. Это происходит, когда индекс не уникален.
    - **`range`**: Используется для поиска по диапазону значений (например, с помощью операторов `BETWEEN` или `IN`).
    - **`index`**: Полный обход индекса. Это быстрее, чем полный обход таблицы.
    - **`ALL`**: Полный обход таблицы. Это самый медленный тип соединения, потому что нужно просмотреть каждую строку таблицы.
    
    **Оптимизация**: Мы стараемся избегать соединений типа `ALL`, так как они самые медленные. Использование индексов может изменить тип соединения на более оптимальный.
    
2. **`possible_keys` и `key`**
    
    - **`possible_keys`**: Это список индексов, которые могут быть использованы для выполнения запроса.
    - **`key`**: Это фактический индекс, который будет использоваться для соединения таблиц. Если это поле пустое, значит, никакой индекс не используется, что может быть признаком низкой производительности.
3. **`rows`** Это важное поле, которое показывает оценочное количество строк, которые должны быть проверены на каждом этапе. Если это значение слишком велико, значит запрос может обрабатывать слишком много данных.
    
4. **`extra`** Это поле содержит дополнительную информацию. Вот некоторые важные значения:
    
    - **`Using index`**: База данных использует индекс для выполнения запроса, что обычно хорошо.
    - **`Using where`**: Запрос использует фильтрацию с помощью `WHERE`, что тоже хорошо.
    - **`Using temporary`**: База данных использует временную таблицу для выполнения запроса. Это может замедлить выполнение.
    - **`Using filesort`**: Происходит сортировка данных на диске (filesort), что также может замедлить запрос.

### Пример вывода `EXPLAIN`:

sql

Копировать код

`+----+-------------+-------+--------+---------------+---------+---------+---------------+------+--------------------------+ | id | select_type | table | type   | possible_keys | key     | key_len | ref           | rows | Extra                    | +----+-------------+-------+--------+---------------+---------+---------+---------------+------+--------------------------+ |  1 | SIMPLE      | u     | ALL    | PRIMARY       | NULL    | NULL    | NULL          | 1000 |                          | |  1 | SIMPLE      | c     | ref    | user_id       | user_id | 4       | u.user_id     | 100  |                          | |  1 | SIMPLE      | s     | ref    | car_id        | car_id  | 4       | c.car_id      | 10   | Using index; Using where | +----+-------------+-------+--------+---------------+---------+---------+---------------+------+--------------------------+`

### Как интерпретировать вывод:

1. **`u` (таблица users)**:
    
    - **`type = ALL`**: Полный обход таблицы, что неэффективно. Можно улучшить производительность, если добавить индекс по полю `user_id`.
    - **`rows = 1000`**: Ожидается, что нужно будет проверить все 1000 строк таблицы `users`.
2. **`c` (таблица cars)**:
    
    - **`type = ref`**: Используется индекс для поиска значений, что более эффективно.
    - **`key = user_id`**: Используется индекс по полю `user_id` для соединения.
    - **`rows = 100`**: Ожидается проверка 100 строк, что лучше, чем полный обход.
3. **`s` (таблица services)**:
    
    - **`type = ref`**: Используется индекс по полю `car_id` для поиска данных.
    - **`key = car_id`**: Это хорошо, так как запрос использует индекс.
    - **`rows = 10`**: Ожидается, что только 10 строк должны быть проверены.
    - **`Extra = Using index; Using where`**: Это говорит о том, что индекс используется эффективно, и выполняется фильтрация данных.

### Оптимизация на основе `EXPLAIN`:

1. **Избегание `ALL`**: В примере выше запрос делает полный обход таблицы `users`. Мы можем добавить индекс на поле `user_id` для улучшения производительности:
    
    sql
    
    Копировать код
    
    `CREATE INDEX idx_user_id ON users(user_id);`
    
    Это уменьшит количество строк, которые нужно просмотреть.
    
2. **Изучение индексов**: Если `possible_keys` содержит несколько индексов, но `key` не выбран, это может означать, что индекс не эффективен или запрос можно переписать для лучшего использования индекса.
    

### Заключение:

`EXPLAIN` — это мощный инструмент для анализа производительности SQL-запросов. Он позволяет понять, как база данных выполняет запрос, и где можно провести оптимизацию. Вот основные шаги:

1. Проанализировать план выполнения запроса через `EXPLAIN`.
2. Определить узкие места (например, тип соединения `ALL` или отсутствие индексов).
3. Оптимизировать запросы, создавая индексы или переписывая запросы для улучшения производительности.

Если у тебя есть конкретные запросы, которые нужно проанализировать, или нужны примеры оптимизации, дай знать!

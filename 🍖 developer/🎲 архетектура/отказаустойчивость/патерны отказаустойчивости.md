https://cantor.fr/design-for-failure/

# Retry
## Exponential backoff
Exponential backoff (экспоненциальная задержка) — это стратегия управления повторными попытками (ретраями), которая используется для отказоустойчивости в системах. Она заключается в том, что время между попытками увеличивается экспоненциально с каждым повтором, что позволяет избежать чрезмерной нагрузки на систему при частых сбоях.

Основная идея состоит в следующем:

1. **Первая попытка** выполняется сразу.
2. **После первой неудачи** система ждет фиксированное время перед следующей попыткой.
3. **Каждая следующая задержка** увеличивается в два раза (или по другой экспоненциальной формуле).

### Пример:

- Первая попытка — 1 секунда.
- Вторая попытка — 2 секунды.
- Третья попытка — 4 секунды.
- Четвертая попытка — 8 секунд.
- И так далее, пока не достигнут максимальный лимит или успех.

Этот подход предотвращает чрезмерное количество запросов в случае временных сбоев (например, при перегрузке серверов) и дает системе время для восстановления. Однако важно учитывать:

- **Максимальный лимит времени ожидания**: чтобы задержки не росли бесконечно, задается максимальное время ожидания.
- **Общее количество попыток**: также ограничивается количество ретраев, чтобы предотвратить бесконечные циклы повторов.

Это эффективный способ повысить отказоустойчивость в распределённых системах или сетевых приложениях.


## Jitter

Jitter — это дополнительная случайная составляющая, которую добавляют к времени задержки между повторными попытками (ретраями), например, в стратегии **экспоненциальной задержки**. Это делается для того, чтобы избежать ситуации, когда несколько клиентов (или процессов) начинают делать повторные попытки одновременно, что может привести к перегрузке системы или сетевого ресурса.

### Зачем нужен Jitter:

Без него, если несколько процессов или клиентов начинают ретрай с одинаковой экспоненциальной задержкой, они могут синхронно посылать повторные запросы, что приведет к всплеску нагрузки в одно и то же время. Jitter помогает "размыть" эти попытки по времени.

### Как работает Jitter:

Jitter добавляется к задержке случайным образом, в пределах заданного диапазона. Например, если система должна ждать 4 секунды перед следующей попыткой, она может вместо этого ждать 3-5 секунд, случайным образом выбирая время из этого диапазона.

### Типы Jitter:

1. **Full Jitter**: Время ожидания выбирается случайным образом в пределах диапазона от 0 до текущего значения задержки.
    
    - Пример: если задержка должна быть 4 секунды, то случайное время будет между 0 и 4 секундами.
2. **Equal Jitter**: Время ожидания разбивается на две части — одна фиксированная, другая случайная.
    
    - Пример: если задержка 4 секунды, система сначала выбирает фиксированное время (например, 2 секунды), а затем добавляет случайное время от 0 до 2 секунд.
3. **Decorrelated Jitter**: Время следующей задержки зависит от предыдущего значения, что позволяет более динамично изменять временные интервалы.
    
    - Пример: новое значение задержки вычисляется как случайное значение между предыдущей задержкой и удвоенным её значением.
    -


# Deadlines
В контексте отказоустойчивости, **дедлайны** (deadlines) — это максимальное время, которое разрешено для завершения операции. Если операция не завершается в пределах этого времени, она считается проваленной и отменяется.

### Принцип работы дедлайнов:

1. **Ограничение по времени**: Каждый запрос или операция получают фиксированное время, после которого система решает прервать выполнение операции. Это позволяет избежать долгих зависаний или блокировок в распределённых системах.
    
2. **Управление ресурсами**: Дедлайны предотвращают долгосрочное занятие ресурсов операциями, которые, скорее всего, не будут успешно завершены.
    
3. **Ошибки и ретраи**: В случае истечения дедлайна операция может быть прервана с ошибкой, и система может либо отменить дальнейшие попытки, либо применить ретрай с экспоненциальной задержкой или другим механизмом обработки отказов.
    

### Пример использования:

В микросервисных архитектурах запрос от одного сервиса к другому может иметь установленный дедлайн. Например, если один сервис запрашивает данные у другого, и тот не отвечает в течение 2 секунд, запрос прерывается, чтобы не держать клиента в ожидании. Клиент может попытаться повторить запрос, либо уведомить пользователя о сбое.

### Почему это важно:

- **Избегание блокировок**: Без дедлайнов, операции могут зависать на неопределённое время, что может привести к потере производительности и отказам системы.
- **Предсказуемость работы системы**: Дедлайны делают поведение системы более предсказуемым, так как операции либо завершаются, либо прерываются в разумные сроки.

### Пример в коде:

В некоторых библиотеках, таких как gRPC, дедлайны устанавливаются явно. Например:

java

Копировать код

`ManagedChannel channel = ManagedChannelBuilder.forTarget("localhost:8080")     .usePlaintext()     .build();  // Устанавливаем дедлайн на 500 миллисекунд stub.withDeadlineAfter(500, TimeUnit.MILLISECONDS).someRpcCall();`

# Rate limiting

**Rate limiting** (ограничение скорости) — это метод управления нагрузкой на системы и ресурсы, который контролирует количество запросов, поступающих от одного клиента (или группы клиентов) за определённый период времени. Этот механизм широко используется для защиты от перегрузки, атак типа DDoS и чрезмерного потребления ресурсов.

### Как работает Rate Limiting:

1. **Ограничение количества запросов**: Устанавливается предел на количество запросов, которые клиент может отправить в определённый промежуток времени. Например, не более 100 запросов за минуту.
2. **Политики ограничения**:
    - **Fixed Window (фиксированное окно)**: В течение каждого фиксированного временного интервала (например, 1 минута) разрешается только определённое количество запросов.
    - **Sliding Window (скользящее окно)**: Окно сдвигается на каждую новую единицу времени, и запросы считаются относительно этого скользящего периода.
    - **Token Bucket (ведро с токенами)**: Каждый запрос "покупается" за токен. Токены накапливаются с постоянной скоростью, и если их нет, запросы блокируются.
    - **Leaky Bucket (протекающее ведро)**: Похож на Token Bucket, но запросы могут быть отправлены с постоянной скоростью. Если ведро переполнено, избыточные запросы отбрасываются.

### Зачем нужен Rate Limiting:

1. **Защита от перегрузки**: Ограничение скорости позволяет предотвратить перегрузку серверов большим количеством запросов.
2. **Предотвращение атак**: Это помогает смягчить атаки типа DDoS, при которых злоумышленники отправляют огромное количество запросов, чтобы вывести систему из строя.
3. **Справедливое распределение ресурсов**: Rate limiting гарантирует, что ресурсы распределяются равномерно среди всех клиентов.

### Пример в реальной жизни:

Представь, что у сервиса есть ограничение на 10 запросов в минуту. Если пользователь превысит это количество, сервис может вернуть ошибку, например, **HTTP 429 Too Many Requests**.

### Пример реализации в коде (Spring Boot):

java

Копировать код

`@RestController @RequestMapping("/api") public class RateLimitedController {      @GetMapping("/resource")     @RateLimit(limit = 5, timeUnit = TimeUnit.MINUTES)     public ResponseEntity<String> getResource() {         return ResponseEntity.ok("Доступ к ресурсу предоставлен");     } }`

Этот пример ограничивает доступ к ресурсу до 5 запросов в минуту.


# Circuit Breaker
**Circuit Breaker** (схема прерывания цепи) — это паттерн отказоустойчивости, который используется для предотвращения системных перегрузок и сбоев в распределённых системах. Он помогает управлять взаимодействием между сервисами и предотвращает ситуации, когда один из сервисов работает с перебоями или полностью недоступен, что может негативно сказаться на всей системе.

### Как работает Circuit Breaker:

1. **Closed (Закрытое состояние)**:
    
    - В этом состоянии Circuit Breaker пропускает все запросы к целевому сервису, как обычно.
    - Если запросы успешны, никаких изменений не происходит.
    - Если происходит несколько сбоев подряд (например, таймауты, ошибки), срабатывает счетчик ошибок. Когда этот счетчик достигает порога (threshold), Circuit Breaker переключается в состояние **Open**.
2. **Open (Открытое состояние)**:
    
    - В открытом состоянии все запросы к целевому сервису блокируются немедленно.
    - Вместо того чтобы пытаться взаимодействовать с "сломавшимся" сервисом, система возвращает ошибку сразу, без попытки отправки запросов.
    - Это защищает сервис от дальнейших перегрузок и предотвращает обострение проблем.
3. **Half-Open (Полуоткрытое состояние)**:
    
    - После определённого времени ожидания (timeout) Circuit Breaker переключается в полуоткрытое состояние, и сервис снова начинает пропускать часть запросов, чтобы проверить, восстановился ли целевой сервис.
    - Если запросы проходят успешно, Circuit Breaker возвращается в состояние **Closed**. Если ошибки продолжаются, он снова переключается в **Open**.

### Пример использования:

Этот паттерн очень полезен, когда один сервис зависит от другого, и зависимый сервис начинает сбоить. Вместо того чтобы ждать таймаутов на каждый запрос, Circuit Breaker блокирует попытки взаимодействия и даёт системе время для восстановления.

### Пример в коде (используя библиотеку Resilience4j в Spring Boot):

java

Копировать код

`import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController;  @RestController public class CircuitBreakerController {      @GetMapping("/externalService")     @CircuitBreaker(name = "myCircuitBreaker", fallbackMethod = "fallbackResponse")     public String callExternalService() {         // Вызов внешнего сервиса         return externalService.call();     }      public String fallbackResponse(Exception ex) {         // Возвращаем ответ при сбое         return "External service is down, please try later.";     } }`

В этом примере, если внешний сервис становится недоступным, активируется Circuit Breaker, и возвращается "fallback" ответ вместо постоянных попыток обращения к зависимому сервису.

### Преимущества Circuit Breaker:

- **Защита системы**: предотвращает перегрузку и сбои.
- **Скорость восстановления**: даёт системе возможность восстанавливаться без избыточной нагрузки.
- **Гибкость**: можно настроить различные пороги срабатывания, таймауты и fallback-ответы.

### Когда использовать:

- Когда один сервис зависит от другого, особенно если зависимость критична.
- В системах с микросервисной архитектурой для управления взаимодействием между сервисами.

# Rich Client

**Rich Client** (богатый клиент) — это архитектурный подход, при котором большая часть логики приложения и пользовательского интерфейса находится на стороне клиента, а сервер выполняет только вспомогательные функции, такие как управление данными и обработка запросов.

### Основные характеристики Rich Client:

1. **Обширная логика на клиенте**:
    
    - Логика приложения и вычисления выполняются на клиентской стороне, что позволяет пользователю взаимодействовать с приложением даже при слабом или нестабильном соединении с сервером.
2. **Меньше запросов к серверу**:
    
    - Так как большая часть работы происходит на клиенте, сервер запрашивается только при необходимости данных или в случае серьёзных операций (например, сохранение информации в базу данных).
3. **Реактивный и интерактивный интерфейс**:
    
    - В Rich Client интерфейс обычно более интерактивный и отзывчивый, что обеспечивает лучший пользовательский опыт. Например, динамическая перезагрузка элементов интерфейса без полной перезагрузки страницы.
4. **Автономная работа**:
    
    - Такие приложения могут частично или полностью работать в офлайн-режиме, а данные синхронизируются с сервером при восстановлении соединения.

### Примеры Rich Client:

1. **Мобильные приложения**: большинство современных мобильных приложений можно считать богатыми клиентами, поскольку основная часть логики находится на устройстве пользователя.
2. **Single-Page Applications (SPA)**: веб-приложения, такие как Gmail, использующие JavaScript-фреймворки (React, Angular, Vue), где вся логика работает на клиенте, а сервер выступает в роли API для получения данных.

### Преимущества Rich Client:

- **Мгновенный отклик**: улучшенный пользовательский опыт благодаря уменьшению количества запросов к серверу и быстрым взаимодействиям.
- **Автономная работа**: пользователи могут продолжать работу даже при потере соединения с сервером, что особенно полезно для мобильных приложений.
- **Меньше нагрузки на сервер**: логика и вычисления на клиентской стороне уменьшают нагрузку на серверную инфраструктуру.

### Недостатки:

- **Сложность разработки**: Rich Client требует более сложного управления состоянием и синхронизацией данных.
- **Требования к устройству**: клиентская сторона выполняет больше работы, что может требовать мощных устройств для нормальной работы.
- **Обновление приложения**: так как большая часть кода находится на стороне клиента, обновления могут стать сложнее по сравнению с тонким клиентом, где изменения вносятся только на сервере.

### Пример: Google Docs

Google Docs — хороший пример Rich Client. Большая часть работы по редактированию текста, форматированию и управлению документом выполняется в браузере (на стороне клиента), а сервер только синхронизирует изменения и сохраняет данные.

### Когда использовать Rich Client:

- Когда приложение должно быть отзывчивым и быстро реагировать на действия пользователя.
- Если необходимо обеспечить автономную работу приложения.
- Когда требуется сложная логика на клиентской стороне (например, редакторы текста, таблиц, сложные визуализации данных).

# Dummy 

**Dummy** (или «заглушка») — это термин, используемый в программировании для описания временных или минимальных версий объектов или данных, которые используются в процессе разработки, тестирования или интеграции системы. Основная цель dummy-объектов — заменить реальные компоненты или данные, чтобы упростить разработку или тестирование.

### Примеры использования Dummy:

1. **Тестовые данные**: В процессе разработки приложения могут использоваться dummy-данные — вымышленные или упрощённые данные, которые заменяют реальные данные для тестирования или демонстрации работы приложения.
    
    Пример:
    
    json
    
    Копировать код
    
    `{   "name": "Dummy User",   "age": 30,   "email": "dummy@example.com" }`
    
2. **Заглушки для сервисов**: Когда один компонент системы ещё не готов или отсутствует, можно использовать dummy-заглушки, чтобы симулировать его работу. Это полезно для тестирования или разработки, когда нет возможности интегрироваться с реальной системой.
    
    Пример: если API пока не готово, ты можешь создать dummy-метод, который всегда возвращает фиксированный ответ:
    
    java
    
    Копировать код
    
    `public User getUser() {     return new User("Dummy User", 30, "dummy@example.com"); }`
    
3. **Mocking в тестировании**: Dummy-объекты часто используются в тестах для симуляции зависимостей, особенно если реальная зависимость тяжело настраивается или требует длительного времени на выполнение. Например, в юнит-тестах можно использовать dummy-сервисы вместо реальных.
    
4. **Интерфейсы с заглушками**: В ранних этапах разработки интерфейсов можно использовать dummy-элементы для имитации поведения и визуализации, даже если функциональность ещё не реализована.
    

### Зачем нужны dummy-объекты:

1. **Упрощение тестирования**: Когда реальные данные недоступны или взаимодействие с реальными сервисами слишком сложно, dummy-объекты помогают изолировать и протестировать отдельные компоненты системы.
    
2. **Ускорение разработки**: Заглушки позволяют начинать разработку зависимых компонентов даже при отсутствии готовой реализации других частей системы.
    
3. **Имитирование поведения**: Они позволяют предсказать поведение системы при взаимодействии с отсутствующими или недоступными ресурсами.
    

### Пример использования Dummy в юнит-тестах:

С помощью Mockito можно создать dummy-объекты для тестирования:

java

Копировать код

`@RunWith(MockitoJUnitRunner.class) public class DummyServiceTest {      @Mock     private ExternalService externalService; // Mock-заглушка для внешнего сервиса      @InjectMocks     private MyService myService;      @Test     public void testDummyService() {         // Устанавливаем dummy-ответ         when(externalService.getData()).thenReturn("Dummy Data");          // Проверяем работу метода         String result = myService.processData();         assertEquals("Processed: Dummy Data", result);     } }`

Здесь `ExternalService` заменяется на dummy-объект с помощью Mockito, чтобы тестировать `MyService` независимо от реального внешнего сервиса.

### Когда использовать Dummy:

- Когда реальные данные или сервисы недоступны на этапе разработки.
- Когда необходимо ускорить разработку или тестирование без интеграции с реальными зависимостями.
- При создании юнит-тестов, когда нужно изолировать тестируемый компонент.

Если хочешь обсудить конкретные примеры использования dummy-объектов в своём проекте, дай знать!

#  другие патерны
Health checing
Caching
Dinamic configuration
Follower
blue-green





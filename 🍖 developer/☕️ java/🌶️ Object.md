[[☕️ Java]]

Класс `Object` в Java является корневым классом всех других классов. Это значит, что каждый класс в Java (неявно или явно) наследуется от `Object`. Все другие классы и объекты, включая те, которые ты создаешь сам, напрямую или косвенно наследуют методы и функциональность, предоставляемую классом `Object`.

# Основные методы

## **equals**
**`public boolean equals(Object obj)`**: Этот метод используется для проверки равенства двух объектов. По умолчанию, `equals` в классе `Object` проверяет равенство ссылок (то есть, два объекта равны, если они указывают на одну и ту же область памяти). Обычно этот метод переопределяют в подклассах, чтобы сравнивать значения полей объектов.
```java
public boolean equals(Object obj) {  
return (this == obj);  
}

```

It is **reflexive**: for any non-null reference value x, x.equals(x) should return true.

It is **symmetric**: for any non-null reference values x and y, x.equals(y) should return true if and only if y.equals(x) returns true.

It is **transitive**: for any non-null reference values x, y, and z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) should return true.

It is **consistent**: for any non-null reference values x and y, multiple invocations of x.equals(y) consistently return true or consistently return false, provided no information used in equals comparisons on the objects is modified.

For any non-null reference value x, x.equals(null) should return false.

## **hashCode**

Насколько это разумно и практично, метод hashCode, определенный классом Object, возвращает отдельные целые числа для отдельных объектов. (Обычно это реализуется путем преобразования внутреннего адреса объекта в целое число, но этот метод реализации не требуется языком программирования Java™.)

### The general contract of hashCode is:
Whenever it is invoked on the same object more than once during an execution of a Java application, the hashCode method must consistently return the same integer, provided no information used in equals comparisons on the object is modified. This integer need not remain consistent from one execution of an application to another execution of the same application.
If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result.
It is not required that if two objects are unequal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce distinct integer results. However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hash tables.

договор
1. Каждый раз, когда он вызывается для одного и того же объекта более одного раза в течение выполнение приложения Java, метод {@code hashCode} должен постоянно возвращать одно и то же целое число
2. Если два объекта равны согласно {@code equals (Object)} затем вызывая метод {@code hashCode} для каждого из два объекта должны давать одинаковый целочисленный результат.
3. Не требуется, чтобы, если два объекта не равны согласно {@link java.lang.Object # equals (java.lang.Object)} затем вызывая метод {@code hashCode} для каждого из два объекта должны давать различные целочисленные результаты
```java
public native int hashCode();
```

## **clone**

```java
protected native Object **clone**()
```
 
 Создает и возвращает копию этого объекта. Точное значение «копии» может зависеть от класса объекта. Общее намерение заключается в том, что для любого объекта x выражение:
x.clone() != x
будет истинным, и что выражение:
x.clone().getClass() == x.getClass()
будет истинным, но это не абсолютные требования. Хотя обычно бывает так, что:
x.clone().equals(x)
будет истинным, это не абсолютные требования.
По соглашению возвращаемый объект должен быть получен путем вызова super.clone. Если класс и все его суперклассы (кроме Object) подчиняются этому соглашению, будет иметь место x.clone().getClass() == x.getClass().
По соглашению объект, возвращаемый этим методом, должен быть независимым от этого объекта (который клонируется). Чтобы добиться этой независимости, может потребоваться изменить одно или несколько полей объекта, возвращаемого super.clone, перед его возвратом. Обычно это означает копирование любых изменяемых объектов, которые составляют внутреннюю «глубокую структуру» клонируемого объекта, и замену ссылок на эти объекты ссылками на копии. Если класс содержит только примитивные поля или ссылки на неизменяемые объекты, то обычно бывает так, что никакие поля в объекте, возвращаемом super.clone, не нужно изменять. Метод clone для класса Object выполняет определенную операцию клонирования. Во-первых, если класс этого объекта не реализует интерфейс Cloneable, то выбрасывается исключение CloneNotSupportedException. Обратите внимание, что все массивы считаются реализующими интерфейс Cloneable, и что возвращаемым типом метода clone типа массива T[] является T[], где T — любой ссылочный или примитивный тип. В противном случае этот метод создает новый экземпляр класса этого объекта и инициализирует все его поля точно с содержимым соответствующих полей этого объекта, как будто по назначению; содержимое полей само по себе не клонируется. Таким образом, этот метод выполняет «поверхностное копирование» данного объекта, а не операцию «глубокого копирования».


## **toString**

```java
public String toString() { return getClass().getName() + "@" + Integer.toHexString(hashCode()); }
```
Возвращает строковое представление объекта. В общем случае метод toString возвращает строку, которая «текстово представляет» этот объект. Результатом должно быть краткое, но информативное представление, которое легко прочесть человеку. Рекомендуется, чтобы все подклассы переопределяли этот метод.
Метод toString для класса Object возвращает строку, состоящую из имени класса, экземпляром которого является объект, символа `@' и беззнакового шестнадцатеричного представления хэш-кода объекта. Другими словами, этот метод возвращает строку, равную значению:
getClass().getName() + '@' + Integer.toHexString(hashCode())

## **notify**

```java
public final native void notify();
```

Пробуждает единственный поток, который ожидает этого объекта монитор. Если какие-либо потоки ожидают этого объекта, один из них выбран для пробуждения. Выбор произвольный и происходит при усмотрение реализации. Поток ожидает объекта отслеживать, вызывая один из методов {@code wait}.

Пробужденный поток не сможет продолжить работу до текущего поток снимает блокировку с этого объекта. Пробужденная нить будет соревноваться обычным образом с любыми другими потоками, которые могут быть

Этот метод должен вызываться только потоком, который является владельцем монитора этого объекта. Тема становится владельцем монитор объекта одним из трех способов:

Путем выполнения метода синхронизированного экземпляра этого объекта. путем выполнения тела оператора {@code synchronized} который синхронизируется на объекте. Для объектов типа {@code Class,} путем выполнения синхронизированный статический метод этого класса.

## **notifyAll**

```java
public final native void notifyAll();
```
Пробуждает все потоки, ожидающие на мониторе этого объекта. А поток ожидает на мониторе объекта, вызывая один из Методы {@code wait}.

Пробужденные потоки не смогут продолжить работу до текущего поток снимает блокировку с этого объекта. Пробужденные нити будет соревноваться обычным образом с любыми другими потоками, которые могут вести активную конкуренцию за синхронизацию на этом объекте; Например, пробужденные нити не пользуются надежными привилегиями или недостатками в быть следующим потоком, который заблокирует этот объект.

[https://www.baeldung.com/java-wait-notify](https://www.baeldung.com/java-wait-notify)

## **wait**
public final native void **wait**(long timeout)
public final void **wait(**long timeout, int nanos)
public final void **wait**()

Заставляет текущий поток ждать, пока какой-либо другой поток не вызовет метод {@link java.lang.Object # notify ()} или метод {@link java.lang.Object # notifyAll ()} для этого объекта или истекло указанное количество времени.

## finalize

```java
protected void finalize()
```
Вызывается сборщиком мусора для объекта при сборке мусора определяет, что больше нет ссылок на объект. Подкласс переопределяет метод {@code finalize} для удаления системные ресурсы или выполнить другую очистку

2.8. Избегайте финализаторов и очистителей (java effekiv )

Один из недостатков финализаторов и очистителей является то, что нет ни­ какой гарантии их своевременного выполнения [25, 12.6].

Запоздалая финализация — проблема не просто теоретическая. Создание финализатора для какого-либо класса может привести к задержке произвольной длины при удалении его экземпляров. Один мой коллега отлаживал приложение GUI, которое было рассчитано на длительное функционирование, но таинствен­ но умирало с ошибкой OutOfMemoryError. Анализ показал, что в момент смерти у этого приложения в очереди на удаление стояли тысячи графических объектов, ждавших вызова финализатора и освобождения памяти. К несчастью, поток финализации выполнялся с меньшим приоритетом, чем другой поток того же приложения, так что удаление объектов не могло выполняться в том же темпе, в каком они становились доступными для финализации. Спецификация языка Java не дает никаких гарантий относительно выполнения финализато­ ров, так что нет никакого переносимого способа предотвратить проблемы та­ кого вида, кроме как просто воздерживаться от использования финализаторов

Спецификация языка программирования Java не только не дает гарантии сво­ евременного вызова финализаторов или очистителей, но и не дает гарантии, что они вообще будут вызваны. Вполне возможно (и даже вероятно), что программа завершится, так и не вызвав их для некоторых объектов, ставших недоступны­ ми. Как следствие вы никогда не должны ставить обновление сохраняемо­ го (persistent) состояния в зависимость от финализатора или очистителя. Например, зависимость от финализатора или очистителя освобождения со­ храняемой блокировки совместно используемого ресурса, такого как база дан­ ных, — верный способ привести всю вашу распределенную систему к краху.

Есть и серьезные проблемы производительности при использовании финализаторов или очистителей.

Финализаторы являются серьезной проблемой безопасности: они от­ крывают ваш класс для атак финализаторов.

## getClass

```
The actual result type is Class<? extends |X|> where |X| is the erasure of the static type of the expression on which getClass is called
```


```java
public final native Class<?> getClass();
```

выводит для Для String " class java.lang.String"

https://habr.com/ru/articles/197802/
https://javarush.com/quests/lectures/questmultithreading.level01.lecture11
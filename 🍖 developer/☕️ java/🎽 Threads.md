# **Threads**


## [[Thread]]
В языке Java поток представляется в виде объекта-потомка класса Thread. Этот класс инкапсулирует стандартные механизмы работы с потоком.  
  
Запустить новый поток можно двумя способами:
 1  (implements Runnable)
 2(extends Thread)

## Основные различия между подходами:

1. **Реализация интерфейса `Runnable`:**
    
    - Более гибкий способ, так как класс может наследовать от другого класса.
    - Рекомендуется, если тебе не нужны дополнительные методы `Thread`.
    - Разделение логики (отделение задачи от механизма потока).
2. **Наследование от `Thread`:**
    
    - Более прямой способ, но ограничивает возможности из-за невозможности наследовать от другого класса.
    - Предпочтительно, если ты хочешь работать с методами `Thread`, такими как `setPriority()`, `getName()`, `setName()`, и т.д.

## Deadlock (взаимная блокировка)

**Deadlock** — это ситуация, когда два или более потока заблокированы навсегда, потому что каждый из них ожидает освобождения ресурса, который удерживается другим потоком. В итоге ни один из потоков не может продолжить выполнение.

#### Пример ситуации с deadlock:
```java
public class DeadlockExample {     
private final Object lock1 = new Object();     
private final Object lock2 = new Object();      
public void method1() {         
	synchronized (lock1) {             
	System.out.println("Thread 1: Holding lock 1...");             
	try { Thread.sleep(10); 
	} catch (InterruptedException e) {}             
	synchronized (lock2) {                 
	System.out.println("Thread 1: Holding lock 1 & 2...");             }         
	}     
	}      
	public void method2() {         
	synchronized (lock2) {             
	System.out.println("Thread 2: Holding lock 2...");             
	try { Thread.sleep(10); } catch (InterruptedException e) {}             synchronized (lock1) {                 
	System.out.println("Thread 2: Holding lock 2 & 1...");             }         
	}     
	} }
```

Здесь два потока могут заблокироваться, если один поток захватит `lock1`, а другой — `lock2`, и оба будут ждать друг друга.

#### Как избежать deadlock:

**Определённый порядок захвата блокировок:** Если все потоки захватывают блокировки в одном и том же порядке, вероятность deadlock сильно снижается. Например, всегда захватывайте сначала `lock1`, а потом `lock2` во всех потоках.

**Использование метода `tryLock`:** В `java.util.concurrent.locks.Lock` есть метод `tryLock()`, который пытается захватить блокировку, но не будет ждать её бесконечно. Если блокировка не может быть захвачена, поток может избежать блокировки.

**Использование таймаутов:** При использовании `tryLock()` можно задать таймаут ожидания. Это помогает избежать бесконечного ожидания и позволяет потоку делать другие полезные действия, если ресурс недоступен.

## **Мьютекс (Mutex)**

**Мьютекс** (сокращение от "mutual exclusion", взаимное исключение) — это примитив синхронизации, который используется для ограничения доступа к ресурсу так, что только один поток может владеть мьютексом (и, соответственно, ресурсом) в любой момент времени.

- **Основная идея:** Мьютекс может быть "захвачен" одним потоком, и пока он удерживается, другие потоки должны ждать, пока мьютекс не будет освобожден. Это гарантирует, что только один поток работает с ресурсом в каждый момент времени.
- **Поведение мьютекса:** Когда поток завершает свою работу с ресурсом, он "освобождает" мьютекс, давая возможность другим потокам захватить его и получить доступ к ресурсу.

#### Пример:

java

Копировать код

`import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock;  public class MutexExample {     private Lock lock = new ReentrantLock(); // Это мьютекс      public void performTask() {         lock.lock(); // Захват мьютекса         try {             System.out.println("Thread " + Thread.currentThread().getName() + " is executing task");             // Код, работающий с общим ресурсом         } finally {             lock.unlock(); // Освобождение мьютекса         }     } }`

### Важные моменты про мьютекс:

- **Только один поток может удерживать мьютекс в любой момент времени.**
- Если поток не освобождает мьютекс, это может привести к deadlock (взаимной блокировке).
- В Java мьютексы реализуются через классы `ReentrantLock`, `Semaphore` и другие примитивы из `java.util.concurrent.locks`.

## **Монитор**

**Монитор** — это концепция, включающая в себя механизм синхронизации и управление потоком. Мониторы часто используются для синхронизации доступа к общим ресурсам и содержат встроенные методы для управления блокировкой потоков, ожидания и уведомления других потоков.

В Java каждый объект фактически является монитором, поскольку у каждого объекта есть встроенная блокировка (lock), которая используется для синхронизации методов или блоков кода.

#### Синхронизация через мониторы в Java:

- **Ключевое слово `synchronized`:** В Java мониторы автоматически используются при использовании ключевого слова `synchronized`. Когда метод или блок кода объявляется как `synchronized`, он захватывает монитор для данного объекта.

#### Пример:

java

Копировать код

`public class MonitorExample {     public synchronized void performTask() {         System.out.println("Thread " + Thread.currentThread().getName() + " is executing task");         // Код, работающий с общим ресурсом     } }`

Здесь используется встроенный монитор объекта. Когда один поток вызывает метод `performTask()`, монитор объекта захватывается этим потоком, и никакие другие потоки не могут войти в синхронизированные методы или блоки этого объекта, пока монитор не будет освобожден.

### Как работают мьютексы и мониторы:

1. **Мьютекс:** Это низкоуровневый механизм, который используется для контроля доступа к ресурсам. Он явно захватывается и освобождается потоками с помощью методов `lock()` и `unlock()`.
    
2. **Монитор:** Это более высокоуровневый механизм синхронизации, встроенный в объекты Java. Он автоматически захватывается при входе в синхронизированные методы или блоки кода с помощью ключевого слова `synchronized`.
    

### Различия между мьютексами и мониторами:

|Характеристика|Мьютекс|Монитор|
|---|---|---|
|**Природа**|Низкоуровневый примитив синхронизации.|Встроенный механизм синхронизации в объектах Java.|
|**Захват/освобождение**|Явно захватывается и освобождается (`lock()`/`unlock()`).|Автоматически захватывается при использовании `synchronized`.|
|**Использование в Java**|Используется через `ReentrantLock`, `Semaphore`.|Используется через `synchronized`.|
|**Уровень**|Позволяет более гибкое управление потоками.|Простота в использовании, но меньше гибкости.|

### Как избежать проблем при использовании мьютексов и мониторов:

1. **Не забывай освобождать мьютексы:** Всегда используй конструкцию `try-finally`, чтобы гарантировать, что мьютекс будет освобожден даже в случае исключения.
    
2. **Определи порядок захвата блокировок:** При использовании нескольких мьютексов или синхронизированных блоков, следи за тем, чтобы все потоки захватывали блокировки в одном и том же порядке. Это помогает избежать deadlock.
    

### Пример использования мониторов для ожидания и уведомления:

java

Копировать код

`public class MonitorWaitNotify {     private final Object monitor = new Object();     private boolean ready = false;      public void waitForTask() throws InterruptedException {         synchronized (monitor) {             while (!ready) {                 monitor.wait(); // Ожидание, пока не произойдет уведомление             }             System.out.println("Task started");         }     }      public void signalTask() {         synchronized (monitor) {             ready = true;             monitor.notify(); // Уведомляем ожидающие потоки         }     } }`

Здесь используется монитор для управления потоками с помощью методов `wait()` и `notify()`, которые позволяют одному потоку ждать выполнения условия, а другому — уведомить его об изменении состояния.

# **Основные классы и интерфейсы java.util.concurrent.locks**

1. **`Lock` (интерфейс)**
    
    Интерфейс `Lock` представляет собой базовый механизм блокировки, который позволяет захватывать и освобождать блокировку явно. В отличие от `synchronized`, который автоматически захватывает и освобождает монитор объекта, методы `Lock` предоставляют более точный контроль.
    
    - **Основные методы:**
        - `void lock()` — захватывает блокировку.
        - `void unlock()` — освобождает блокировку.
        - `boolean tryLock()` — пытается захватить блокировку без ожидания. Возвращает `true`, если блокировка была захвачена, и `false`, если нет.
        - `void lockInterruptibly()` — захватывает блокировку, но позволяет прерывать поток, пока он ждет блокировку.
    
    **Когда использовать `Lock`:**
    
    - Когда нужен точный контроль над блокировкой и освобождением.
    - Если требуется функция прерывания ожидания (`lockInterruptibly()`).
    - Если нужно использовать `tryLock()` для избежания deadlock.
    - Когда требуется справедливая блокировка (например, в `ReentrantLock`).
    
    **Пример:**
    
    java
    
    Копировать код
    
    `Lock lock = new ReentrantLock(); lock.lock(); try {     // критическая секция } finally {     lock.unlock(); }`
    

---

2. **`ReentrantLock` (класс)**
    
    `ReentrantLock` — это одна из реализаций интерфейса `Lock`. Этот класс предоставляет механизм блокировки с возможностью "реэнтрантности" (повторного захвата). Это означает, что поток, который уже захватил блокировку, может снова её захватить без блокировки самого себя.
    
    - **Основные особенности:**
        - Может быть "справедливым" (честным), если передать `true` в конструктор. В справедливом режиме блокировка распределяется потокам в порядке их запроса.
        - Предоставляет методы для проверки состояния блокировки (`isLocked()`, `isHeldByCurrentThread()`).
    
    **Когда использовать `ReentrantLock`:**
    
    - Когда нужно явное управление блокировкой (например, при необходимости прерывания ожидания или попытки захвата блокировки).
    - Когда требуется реэнтрантная блокировка, которая позволяет одному и тому же потоку захватывать блокировку несколько раз.
    - Когда важна справедливость доступа (FIFO).
    
    **Пример:**
    
    java
    
    Копировать код
    
    `Lock lock = new ReentrantLock(true); // "true" означает справедливую блокировку lock.lock(); try {     // критическая секция } finally {     lock.unlock(); }`
    

---

3. **`ReadWriteLock` (интерфейс)**
    
    Интерфейс `ReadWriteLock` предоставляет два типа блокировок: одну для операций чтения и одну для операций записи. Это позволяет разделить потоки на "читателей" и "писателей". Несколько потоков могут одновременно читать данные, но только один поток может писать.
    
    - **Основные методы:**
        - `Lock readLock()` — возвращает блокировку для чтения.
        - `Lock writeLock()` — возвращает блокировку для записи.
    
    **Когда использовать `ReadWriteLock`:**
    
    - Когда важно разделение операций на чтение и запись.
    - Если данные чаще читаются, чем изменяются, так как несколько потоков могут одновременно захватывать `readLock`, что повышает производительность.
    - Для предотвращения конфликтов, когда одна операция записи может блокировать все операции чтения и другие записи.
    
    **Пример:**
    
    java
    
    Копировать код
    
    `ReadWriteLock rwLock = new ReentrantReadWriteLock(); Lock readLock = rwLock.readLock(); Lock writeLock = rwLock.writeLock();  // Для операций чтения readLock.lock(); try {     // код для чтения данных } finally {     readLock.unlock(); }  // Для операций записи writeLock.lock(); try {     // код для изменения данных } finally {     writeLock.unlock(); }`
    

---

4. **`Condition` (интерфейс)**
    
    Интерфейс `Condition` используется вместе с `Lock` и предоставляет аналог функциональности `wait()`/`notify()`/`notifyAll()` для работы с состояниями потока.
    
    - **Основные методы:**
        - `await()` — заставляет поток ожидать, пока его не разбудят.
        - `signal()` — пробуждает один поток, который ждет на этом объекте `Condition`.
        - `signalAll()` — пробуждает все потоки, которые ждут на этом объекте `Condition`.
    
    **Когда использовать `Condition`:**
    
    - Когда нужно более гибкое управление ожиданием и пробуждением потоков.
    - В ситуациях, когда нужно работать с несколькими условиями (в отличие от единственного состояния, управляемого `wait()`/`notify()`).
    
    **Пример:**
    
    java
    
    Копировать код
    
    `Lock lock = new ReentrantLock(); Condition condition = lock.newCondition();  lock.lock(); try {     while (!conditionMet()) {         condition.await(); // Ожидание, пока условие не будет выполнено     }     // критическая секция } finally {     lock.unlock(); }  // В другом потоке lock.lock(); try {     // Обновление состояния     condition.signal(); // Пробуждаем поток } finally {     lock.unlock(); }`
    

---

5. **`StampedLock` (класс)**
    
    `StampedLock` — это новый тип блокировки, который был введен в Java 8. Он обеспечивает возможность использования как эксклюзивных блокировок (аналогичных `ReentrantLock`), так и блокировок для чтения/записи (аналогичных `ReadWriteLock`). Однако `StampedLock` предлагает более быстрые и легковесные операции.
    
    - **Особенности:**
        - Предоставляет метод "оптимистичной" блокировки для чтения (`tryOptimisticRead()`), который может проверить, было ли изменение данных.
        - Это более легковесная альтернатива традиционным блокировкам, которая может повысить производительность в сценариях с низкой конкуренцией.
    
    **Когда использовать `StampedLock`:**
    
    - Если важна высокая производительность при низкой конкуренции на доступ к ресурсам.
    - Когда необходимы как эксклюзивные блокировки, так и оптимистичные блокировки для чтения.
    
    **Пример:**
    
    java
    
    Копировать код
    
    `StampedLock lock = new StampedLock(); long stamp = lock.tryOptimisticRead(); // проверяем состояние данных if (!lock.validate(stamp)) {     stamp = lock.readLock();     try {         // безопасное чтение данных     } finally {         lock.unlockRead(stamp);     } }`
    

---

### Вывод: когда что использовать?

- **`ReentrantLock`**: Используй, когда тебе нужно более гибкое управление блокировкой (например, возможность прерывания, попытка захвата блокировки) или если тебе нужно повторное захватывание блокировки одним и тем же потоком.
- **`ReadWriteLock`**: Отлично подходит для ситуаций, когда данные чаще читаются, чем изменяются, и требуется одновременный доступ множества потоков к ресурсу для чтения.
- **`Condition`**: Полезен, когда нужно работать с многими условиями ожидания и пробуждения потоков, вместо использования одного монитора.
- **`StampedLock`**: Подходит для сценариев с низкой конкуренцией на доступ к ресурсам, где важна производительность и оптимистичные чтения.
# **Virtual Threads**

Виртуальные потоки изначально были введены в язык Java как предварительная функция в Java 19 и дополнительно доработаны в Java 20. В Java 21 были введены некоторые новые изменения.

**Виртуальные потоки — это легкие потоки, предназначенные для сокращения усилий по разработке высококонкурентных приложений.** Традиционные потоки, также называемые потоками платформы, представляют собой тонкие оболочки вокруг потоков ОС. Одна из основных проблем с потоками платформы заключается в том, что они запускают код в потоке ОС и захватывают поток ОС на протяжении всего его жизненного цикла. Существует ограничение на количество потоков ОС, и это создает узкое место масштабируемости.

**Как и потоки платформы, виртуальный поток также является экземпляром класса _java.lang.Thread_ , но он не привязан к определенному потоку ОС** . Он запускает код в определенном потоке ОС, но не захватывает поток на весь срок службы. Поэтому многие виртуальные потоки могут совместно использовать потоки ОС для запуска своего кода.

Давайте рассмотрим использование виртуального потока на примере:

```java
try(var executor = Executors.newVirtualThreadPerTaskExecutor()) {
    IntStream.rangeClosed(1, 10_000).forEach(i -> {
        executor.submit(() -> {
            System.out.println(i);
            try {
                Thread.sleep(Duration.ofSeconds(1));
            } 
            catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
    });
}
```

В приведенном выше фрагменте кода мы используем статический метод _newVirtualThreadPerTaskExecutor()_ . Этот исполнитель создает новый виртуальный поток для каждой задачи, поэтому в приведенном выше примере мы создаем _10 000_  виртуальных потоков.

В Java 21 появились два важных изменения в виртуальных потоках:

- Виртуальные потоки теперь всегда поддерживают локальные переменные потока.
- Виртуальные потоки создаются с помощью API _Thread.Builder_ , которые также отслеживаются в течение всего срока их существования и видны в новом дампе потока.

# **ThreadLocal**

### Основные концепции `ThreadLocal`:

1. **Отдельная копия переменной для каждого потока**: Когда поток обращается к `ThreadLocal` переменной, он получает свою собственную копию этой переменной. Изменения этой переменной не будут видны другим потокам.
2. **Методы `ThreadLocal`**:
    - `get()`: возвращает значение, связанное с текущим потоком.
    - `set(T value)`: устанавливает значение для текущего потока.
    - `remove()`: удаляет значение, связанное с текущим потоком.

### Пример использования `ThreadLocal`:

```java
public class ThreadLocalExample {

    // Создаём ThreadLocal переменную
    private static ThreadLocal<Integer> threadLocalValue = ThreadLocal.withInitial(() -> 1);

    public static void main(String[] args) {
        // Поток 1
        Thread thread1 = new Thread(() -> {
            threadLocalValue.set(100);
            System.out.println("Thread 1 value: " + threadLocalValue.get());
        });

        // Поток 2
        Thread thread2 = new Thread(() -> {
            threadLocalValue.set(200);
            System.out.println("Thread 2 value: " + threadLocalValue.get());
        });

        // Запускаем потоки
        thread1.start();
        thread2.start();
    }
}
```

### Что происходит в примере:

- `threadLocalValue` — это переменная, у которой для каждого потока будет своя копия.
- В первом потоке переменная будет равна `100`, а во втором — `200`.
- Когда два потока одновременно работают с одной и той же переменной `threadLocalValue`, они видят только своё значение и не влияют друг на друга.

### Важные моменты:

- **Изолированность данных**: ThreadLocal гарантирует, что данные между потоками изолированы. Это полезно, когда ты работаешь с ресурсами, которые не могут быть безопасно разделены между потоками, например, с транзакциями.
- **Утечки памяти**: Не забудь вызывать `remove()`, чтобы избежать утечек памяти. Если поток завершит работу, но значение переменной останется в памяти, это может привести к проблемам с памятью.

### Применение в транзакциях:

Когда Spring открывает транзакцию, она привязывается к текущему потоку через `ThreadLocal`. Пока этот поток выполняет операции, транзакция активна. Если ты попытаешься использовать транзакцию в другом потоке, её там просто не будет, потому что другой поток имеет свою собственную копию `ThreadLocal`.

Надеюсь, это проясняет, как работает `ThreadLocal`! Хочешь попробовать более сложные примеры или рассмотреть конкретный случай использования?
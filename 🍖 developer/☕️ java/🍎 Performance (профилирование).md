
[[☕️ Java]]
# **Отображение процессов**

Для отображения и анализа процессов Java через консоль существует несколько инструментов, которые могут помочь тебе получить подробную информацию о работе JVM, её состоянии, потреблении ресурсов, потоках и т.д. Давай рассмотрим основные и наиболее полезные инструменты, которые ты можешь использовать.

- **jps** — для отображения запущенных Java-процессов.
- **jstack** — для получения дампа потоков.
- **jmap** — для анализа памяти и создания дампов.
- **jstat** — для мониторинга производительности JVM в реальном времени.
- **jcmd** — мощный инструмент для выполнения различных диагностических команд.
- **top/htop**, **ps**, **netstat**, **strace**, **lsof** — для общего мониторинга процессов и ресурсов операционной системы.


### 1. **jps (Java Process Status Tool)**

Мы уже обсуждали `jps`, но это один из основных инструментов для отображения всех запущенных процессов Java. С его помощью можно получить идентификаторы процессов (PID) и основные сведения о том, какие Java-программы запущены.

`jps -lvm`

- **-l**: Полное имя класса или JAR.
- **-v**: Аргументы JVM.
- **-m**: Аргументы, переданные программе.

### 2. **jstack** (Java Stack Trace)

**jstack** используется для получения дампа состояния потоков (thread dump) в процессе Java. Это полезно для анализа зависаний, блокировок и других проблем с многопоточностью.

`jstack <PID>`

Это выведет полный дамп всех потоков процесса с идентификатором **PID**. Ты сможешь увидеть состояние каждого потока, его стек вызовов и информацию о возможных взаимных блокировках (deadlocks).

#### Пример использования:

`jstack 12345`

- Это покажет стек вызовов всех потоков в процессе с **PID 12345**.

### 3. **jmap** (Memory Map Tool)

**jmap** используется для анализа состояния памяти JVM. Он позволяет создавать дампы памяти (heap dump), а также выводить статистику по объектам в памяти.

#### Получить сводку использования памяти:

`jmap -heap <PID>`

- Эта команда покажет состояние heap: используемую и свободную память, сборку мусора, а также информацию о разделе памяти PermGen (для Java 7 и ниже) или Metaspace (начиная с Java 8).

#### Создать дамп памяти:

`jmap -dump:format=b,file=heap_dump.hprof <PID>`

- Это создаст файл дампа памяти, который можно проанализировать с помощью инструментов, таких как **Eclipse Memory Analyzer (MAT)**.

### 4. **jstat** (JVM Statistics Monitoring Tool)

**jstat** — это инструмент мониторинга, который позволяет отслеживать производительность JVM в реальном времени. Он предоставляет статистику о работе сборщика мусора, памяти, загрузке классов и других метриках JVM.

#### Пример мониторинга сборщика мусора:

`jstat -gc <PID> 1000`

- Эта команда будет выводить статистику сборки мусора для процесса с **PID**, обновляя информацию каждые 1000 миллисекунд.

#### Пример мониторинга загрузки классов:

`jstat -class <PID>`

- Это покажет информацию о количестве загруженных и выгруженных классов, а также объем памяти, используемый классами.

### 5. **jcmd** (Java Diagnostic Command)

**jcmd** — это мощный инструмент для выполнения диагностических команд на работающем Java-процессе. Он может выполнять практически все функции, которые предоставляют инструменты, такие как **jstack**, **jmap**, **jstat**, и многое другое.

#### Вывести список доступных команд для процесса:

`jcmd <PID> help`

Это покажет все команды, которые ты можешь выполнить для данного процесса.

#### Получить стек вызовов:

`jcmd <PID> Thread.print`

- Эта команда аналогична `jstack` и выводит дамп потоков.

#### Создать дамп памяти:

`jcmd <PID> GC.heap_dump <file-path>`

- Это создаст дамп heap памяти в указанном файле.

#### Выполнить сборку мусора:

`jcmd <PID> GC.run`

- Эта команда инициирует сборку мусора в процессе с **PID**.

### 6. **top и htop (для мониторинга общего состояния процессов)**

Для общего мониторинга системных ресурсов ты можешь использовать такие утилиты, как **top** или **htop** (на Linux/macOS). Эти команды помогут тебе отслеживать использование процессора, памяти и другие метрики, связанные с процессами Java.

`top -p <PID>`

- Это покажет информацию о процессе Java с указанным PID.

### 7. **ps (Process Status)**

Команда **ps** может использоваться для отображения всех процессов, включая процессы Java. С её помощью можно получить базовую информацию о потреблении ресурсов процессом Java.

`ps -ef | grep java`

- Эта команда покажет все процессы Java на текущем хосте, их PID, пользователя, от имени которого они запущены, и аргументы запуска.

### 8. **netstat (для мониторинга сетевых соединений)**

Если Java-приложение использует сеть (например, веб-сервер или API), команда **netstat** поможет мониторить активные сетевые соединения и порты.

`netstat -anp | grep java`

- Это покажет все сетевые соединения, установленные процессами Java, а также используемые порты.

### 9. **strace (для отладки системных вызовов)**

**strace** — это инструмент для отслеживания системных вызовов и сигналов, поступающих в процесс. Это полезно для отладки проблем, связанных с взаимодействием Java-приложения с операционной системой.

#### Пример:

`strace -p <PID>`

- Это покажет системные вызовы, выполняемые процессом с указанным **PID**.

### 10. **lsof (List Open Files)**

**lsof** — это утилита, которая позволяет вывести список всех открытых файлов и сетевых соединений, используемых процессом. Это полезно для мониторинга ресурсов, используемых Java-процессом.

`lsof -p <PID>`

- Это покажет все файлы, к которым процесс с указанным **PID** имеет доступ.


# **jconsole**

```bash
$jconsole 889988
```


**JConsole** — это стандартный инструмент мониторинга и управления приложениями на Java, который поставляется вместе с JDK. Он предназначен для отслеживания состояния виртуальной машины Java (JVM), мониторинга производительности и управления Java-программами через **JMX (Java Management Extensions)**.

### Основные возможности JConsole:

1. **Мониторинг использования памяти**:
    
    - JConsole позволяет отслеживать использование heap и non-heap памяти JVM в реальном времени.
    - Ты можешь наблюдать за тем, как собирается мусор (Garbage Collection) и сколько памяти используется объектами приложения.
2. **Мониторинг потоков**:
    
    - JConsole отображает активные потоки JVM и показывает их состояние: выполняются, ждут или заблокированы.
    - Можно отслеживать deadlocks (взаимные блокировки) и получать информацию о текущем состоянии всех потоков.
3. **Мониторинг CPU**:
    
    - JConsole отслеживает, сколько процессорного времени используется JVM.
    - Ты можешь видеть, как процессорная нагрузка изменяется с течением времени и насколько эффективно приложение использует CPU.
4. **Управление MBeans через JMX**:
    
    - JConsole позволяет управлять и взаимодействовать с MBeans (Managed Beans) в твоём приложении. Ты можешь отслеживать метрики, управлять состоянием компонентов или выполнять команды прямо через консоль.
    - Например, ты можешь изменить конфигурационные параметры приложения или инициировать определённые действия через зарегистрированные MBeans.
5. **Статистика производительности**:
    
    - Ты можешь отслеживать общее количество классов, загруженных JVM, их загрузку и выгрузку, а также другую информацию о работе JVM.
6. **Настройка Garbage Collection (GC)**:
    
    - JConsole позволяет наблюдать за процессом сборки мусора в JVM: сколько памяти освобождено и как часто происходят сборки.

### Как запустить JConsole:

1. **Запуск JConsole**:
    
    Если ты используешь JDK, JConsole уже установлена вместе с ним. Ты можешь запустить её из командной строки, выполнив команду:
    
    bash
    
    Копировать код
    
    `jconsole`
    
    Это откроет графический интерфейс JConsole.
    
2. **Выбор JVM-процесса**:
    
    При запуске JConsole она автоматически покажет список всех запущенных локальных процессов JVM. Ты можешь выбрать нужный процесс для мониторинга.
    
    Также JConsole поддерживает подключение к удалённым JVM через JMX, если они настроены для удалённого доступа.
    

### Вкладки JConsole:

1. **Overview (Обзор)**:
    
    - Обзор общей информации о производительности JVM: использование памяти, загрузка CPU, количество активных потоков, количество загруженных классов.
2. **Memory (Память)**:
    
    - Графики, показывающие использование памяти (heap и non-heap), а также данные о сборке мусора.
    - Ты можешь вручную вызвать сборку мусора, нажав на кнопку **Perform GC**.
3. **Threads (Потоки)**:
    
    - Отображает состояние всех потоков, запущенных в JVM: активные, заблокированные, ожидающие.
    - Позволяет отслеживать deadlock и другие проблемы, связанные с многопоточностью.
4. **Classes (Классы)**:
    
    - Информация о количестве загруженных классов, а также о том, сколько классов было выгружено.
    - Это помогает понять, как динамически загружаются и выгружаются классы в твоём приложении.
5. **CPU (Процессор)**:
    
    - График, показывающий использование CPU процессом JVM.
    - Позволяет увидеть, как изменяется нагрузка на процессор с течением времени.
6. **MBeans**:
    
    - Самая мощная вкладка для управления и мониторинга. Она позволяет взаимодействовать с MBeans через JMX.
    - Ты можешь отслеживать метрики и конфигурации, управлять настройками и выполнять команды, предоставленные MBeans.

### Пример использования JConsole для мониторинга:

1. **Подключение к локальной JVM**:
    
    - Запусти JConsole и выбери процесс, который ты хочешь мониторить.
2. **Мониторинг использования памяти**:
    
    - Перейди на вкладку **Memory**, чтобы отслеживать, как используется heap и non-heap память твоим приложением.
    - Ты также можешь запустить ручную сборку мусора (GC) для освобождения памяти.
3. **Анализ потоков**:
    
    - На вкладке **Threads** можно увидеть все активные потоки и их состояния. Если возникает проблема с блокировками или потоками, эта вкладка поможет в диагностике.
4. **Работа с MBeans**:
    
    - Если твое приложение зарегистрировало MBeans через JMX, на вкладке **MBeans** ты можешь их найти и управлять ими: просматривать метрики, изменять параметры конфигурации или выполнять определённые действия (например, перезагрузку сервиса).

### Когда использовать JConsole:

- **Мониторинг в реальном времени**: JConsole идеально подходит для отслеживания производительности приложения, работающего в JVM, особенно если тебе нужно увидеть, как оно использует память, потоки и процессорные ресурсы.
- **Отладка и диагностика**: JConsole помогает диагностировать проблемы с производительностью и многопоточностью в реальном времени, позволяя анализировать состояние потоков и использование ресурсов.
- **Управление через JMX**: С помощью JConsole можно управлять и взаимодействовать с приложениями, поддерживающими JMX, выполняя задачи администрирования прямо через консоль.

[[performance (fn]]


# **Java VisualVM**

Это мощный инструмент для мониторинга, профилирования и анализа производительности приложений, работающих на **Java Virtual Machine (JVM)**. Java VisualVM входит в состав JDK и предоставляет множество функций для диагностики приложений.

### Основные возможности Java VisualVM:

1. **Мониторинг работы JVM**:
    
    - Ты можешь подключаться к работающим JVM-процессам и отслеживать их состояние в реальном времени.
    - Отслеживание использования процессора (CPU), оперативной памяти (heap и non-heap memory), количества активных потоков и их состояния.
    - Поддержка просмотра графиков по сборке мусора (Garbage Collection).
2. **Профилирование производительности**:
    
    - **CPU Profiler**: позволяет измерять, какие методы потребляют наибольшую долю процессорного времени, чтобы выявить узкие места в производительности.
    - **Memory Profiler**: отслеживает использование памяти, чтобы увидеть, сколько памяти выделяется различным объектам и классу, что помогает в диагностике утечек памяти.
3. **Отладка памяти (Heap Dump)**:
    
    - Возможность снимать дампы памяти (heap dumps) и анализировать содержимое памяти JVM. Это помогает найти объекты, которые занимают много места в памяти, и понять причины утечек памяти.
    - VisualVM также позволяет анализировать метаданные классов, строки и другие объекты, находящиеся в памяти.
4. **Управление MBeans через JMX**:
    
    - Java VisualVM поддерживает JMX (Java Management Extensions), что позволяет мониторить и управлять MBeans, если они зарегистрированы в твоём приложении.
    - Это особенно полезно для наблюдения за метриками производительности и других данных, доступных через JMX-интерфейсы.
5. **Мониторинг потоков**:
    
    - VisualVM предоставляет информацию о потоках, выполняемых в JVM: сколько потоков активно, в каком они состоянии (ожидание, выполнение и т.д.).
    - Помогает в отладке проблем с многопоточностью (deadlock, thread contention).
6. **Анализ времени отклика**:
    
    - Ты можешь отслеживать и анализировать задержки выполнения методов или обработки событий в приложении.

### Как использовать Java VisualVM:

1. **Запуск Java VisualVM**:
    
    - VisualVM поставляется вместе с JDK, и его можно запустить из папки JDK (обычно находится в директории `jdk/bin` под названием `jvisualvm`).
    - Также ты можешь скачать его отдельно, если у тебя его нет в дистрибутиве JDK.
2. **Подключение к работающим JVM**:
    
    - Когда ты запускаешь VisualVM, он автоматически отображает все локальные процессы JVM, которые в данный момент запущены. Ты можешь выбрать нужный процесс и начать мониторинг.
    - Можно подключаться и к удалённым JVM через JMX.
3. **Профилирование**:
    
    - Чтобы начать профилирование, выбери процесс, который ты хочешь анализировать, и включи CPU или Memory профилирование.
    - VisualVM предоставит подробный анализ потребления ресурсов и время выполнения методов.

### Пример сценария использования:

- Допустим, у тебя есть Java-приложение, которое работает медленнее, чем ожидалось, или потребляет слишком много памяти.
- Ты можешь запустить **Java VisualVM**, подключиться к своему приложению, начать профилирование CPU и памяти и увидеть, какие методы или объекты потребляют наибольшее количество ресурсов.
- На основе этих данных можно оптимизировать код, например, уменьшить количество вызовов "тяжёлых" методов или оптимизировать использование памяти.

### Важные фичи:

- **Плагины**: Java VisualVM поддерживает плагины для расширения функциональности. Можно добавить плагины для работы с конкретными фреймворками или технологиями.
- **Поддержка различных версий JDK**: Инструмент поддерживает работу с различными версиями JDK, включая старые и новые.

### Пример использования:

1. **Запуск VisualVM**:
    Открой командную строку или терминал и выполни команду для запуска VisualVM:

```bash
$jvisualvm
```
        
2. **Выбор процесса**:
    
    - Ты увидишь список всех запущенных JVM-процессов. Выбери тот, который нужно профилировать.
3. **Профилирование CPU**:
    
    - В разделе "Profiler" включи профилирование CPU и нажми "Start".
    - После того как соберётся достаточное количество данных, ты сможешь увидеть, какие методы потребляют больше всего процессорного времени.
4. **Анализ использования памяти**:
    
    - Ты можешь создать дамп памяти (heap dump) и проанализировать его, чтобы увидеть, какие объекты занимают много места в памяти.### 1. **Оптимизация использования памяти**


# **Оптимизация памяти**
Перед тем, как прибегать к более сложным решениям, стоит проанализировать, как приложение использует память, и попытаться уменьшить её потребление.

- **Профилирование памяти**: Используй инструменты профилирования (например, `VisualVM`, `JProfiler`, `YourKit`), чтобы понять, какие части приложения потребляют больше всего памяти, и существуют ли утечки памяти.
    
- **Удаление утечек памяти**: Утечки памяти (memory leaks) могут быть причиной того, что приложение потребляет больше памяти, чем необходимо. Проверь, нет ли ситуаций, когда объекты удерживаются в памяти дольше, чем нужно.
    
- **Уменьшение объёма данных**: Если приложение хранит в памяти большие объемы данных, можно подумать о сжатии или частичном хранении на диске (например, с использованием таких структур, как LRU-кэш, чтобы хранить в памяти только наиболее часто используемые данные).
    
- **Оптимизация коллекций**: Некоторые коллекции могут занимать слишком много памяти. Например, использование `ArrayList` вместо `LinkedList` может снизить накладные расходы на хранение данных. Также можно использовать более компактные структуры данных или более эффективные типы (например, `int[]` вместо `Integer[]`).
    

### 2. **Увеличение доступной памяти (масштабирование)**

- **Увеличение объема оперативной памяти на сервере**: Самый простой путь — увеличить физическую оперативную память. Если это возможно, добавь больше RAM на сервер, где выполняется приложение.
    
- **Изменение настроек JVM**: В Java можно изменить максимальный размер heap-памяти с помощью флага `-Xmx`. Например, если приложение использует больше памяти, чем по умолчанию разрешено JVM, можно увеличить её предел:
    
    bash
    
    Копировать код
    
    `java -Xmx4G MyApplication`
    
    Это позволит JVM выделить до 4 ГБ памяти для heap. Однако этот подход полезен только в том случае, если на сервере действительно доступно достаточно оперативной памяти.
    

### 3. **Использование виртуальной памяти (paging/swapping)**

Операционные системы могут использовать **виртуальную память** для работы с большими приложениями. Виртуальная память использует файл подкачки (swap) на диске для хранения данных, которые не помещаются в RAM.

- **Плюсы**: Это позволяет приложению работать, даже если оно превышает физический объем оперативной памяти.
    
- **Минусы**: Доступ к данным в свопе (swap) значительно медленнее, чем к данным в RAM, особенно на обычных жестких дисках (HDD). Использование swap-файла на SSD может улучшить производительность, но все равно будет значительно медленнее по сравнению с RAM.
    

### 4. **Кэширование данных на диске**

Если приложение работает с большими объёмами данных, которые нельзя хранить полностью в памяти, можно использовать кэширование данных на диске. Это позволит хранить только наиболее важные данные в оперативной памяти, а остальные — на более медленных носителях (например, на SSD).

- **Пример: использование кэшей**: Для этого можно использовать кэш-стратегии вроде LRU (Least Recently Used), где часто используемые данные остаются в памяти, а остальные данные выгружаются на диск.
    
- **Инструменты**: Такие библиотеки, как **Ehcache** или **Caffeine**, могут быть использованы для организации эффективного кэширования данных на диске.
    

### 5. **Разделение приложения (Sharding/Splitting)**

Если приложение слишком большое, его можно разбить на несколько частей, каждая из которых потребляет меньше памяти.

- **Микросервисы**: Один из вариантов — разделить приложение на микросервисы. Вместо одного большого монолитного приложения, каждая функция или компонент становятся отдельным сервисом, потребляющим меньше ресурсов.
    
- **Шардирование данных**: Если приложение работает с большими объемами данных, можно разделить данные на шардированные сегменты, что позволит каждому процессу работать с меньшим объемом данных.
    

### 6. **Использование внешних систем хранения данных**

Вместо того чтобы хранить большие объемы данных в оперативной памяти, можно использовать внешние системы хранения, такие как базы данных, кэш-системы или распределенные хранилища данных.

- **Базы данных**: Держи только ключевые данные в памяти, а остальные — в базе данных. Например, в случае работы с большими коллекциями можно хранить данные в базе данных, загружая только те части, которые необходимы для текущих операций.
    
- **Кэш-системы**: В таких случаях можно использовать **Redis** или **Memcached** для кэширования данных, которые часто требуются, но не должны храниться в оперативной памяти постоянно.
    
- **Распределённые системы хранения**: Если данные очень велики, можно рассмотреть использование распределённых систем, таких как **Apache Cassandra** или **Hadoop**, где данные разбиваются на несколько узлов, и каждый узел отвечает за хранение части данных.
    

### 7. **Оптимизация потоков и многозадачности**

Некоторые приложения используют слишком много потоков или процессов, что увеличивает накладные расходы на оперативную память.

- **Оптимизация использования потоков**: Проверь, сколько потоков одновременно выполняется в приложении. Может быть, некоторые потоки работают параллельно, но конкурируют за память.
    
- **Пул потоков**: Использование пула потоков может снизить нагрузку на память, поскольку ты можешь ограничить количество одновременно выполняемых задач.
    

### 8. **Распределение нагрузки на несколько серверов**

Если приложение потребляет слишком много ресурсов, можно рассмотреть его горизонтальное масштабирование:

- **Кластеризация**: Распределить нагрузку между несколькими серверами. Пример — балансировка нагрузки с использованием **Kubernetes** или **Docker Swarm**.
    
- **Разделение работы между узлами**: Можно разделить выполнение приложений или работу с данными между несколькими узлами (например, с помощью кластеров баз данных или распределённых вычислений).
    

### 9. **Анализ и оптимизация алгоритмов**

Иногда проблема потребления памяти связана с неоптимальными алгоритмами. Перепроверка алгоритмов может помочь снизить их сложность и, как следствие, уменьшить потребление ресурсов.

- **Оптимизация структур данных**: Проверьте, можно ли использовать более эффективные структуры данных, чтобы уменьшить использование памяти.
    
- **Lazy-загрузка данных**: Загружай данные по мере необходимости, а не загружай всё сразу в память.

# **Spring Boot Starter**

**Стартер** (или **Spring Boot Starter**) — это удобный механизм в экосистеме **Spring Boot**, который позволяет легко подключать зависимости и конфигурации для определённых технологий или библиотек в проекте. Spring Boot Starter предоставляет набор преднастроенных зависимостей, которые включают необходимые библиотеки для работы с различными технологиями (например, Spring Data, Spring Security, JPA, Web и т.д.).

### Зачем нужен стартер?

Стартеры в Spring Boot позволяют:

1. **Упрощение настройки зависимостей**: Вместо того, чтобы вручную добавлять множество библиотек и зависимости для каждой технологии, стартеры группируют их в одном месте и делают подключение автоматизированным и простым.
    
2. **Предустановленные конфигурации**: Стартеры содержат базовые конфигурации, что позволяет начать работу с технологией без необходимости разбираться в деталях настройки. Например, стартер для работы с базой данных автоматически добавит все нужные зависимости и создаст базовые конфигурации для подключения.
    
3. **Лёгкость добавления новых технологий**: Чтобы подключить какую-то технологию, достаточно добавить соответствующий стартер в файл конфигурации проекта (например, `pom.xml` или `build.gradle`), и все необходимые зависимости будут подключены автоматически.
    

### Примеры стандартных стартеров:

- **`spring-boot-starter-web`**: для создания веб-приложений на базе Spring MVC.
- **`spring-boot-starter-data-jpa`**: для работы с базами данных через JPA.
- **`spring-boot-starter-security`**: для добавления механизмов аутентификации и авторизации.
- **`spring-boot-starter-test`**: для добавления всех необходимых инструментов для тестирования приложения.

### Как создать свой собственный стартер?

1. **Создание нового Maven проекта**:
    - Для создания стартеров обычно используется **Maven**, так как стартеры — это всего лишь набор зависимостей и предустановок, собранных в проект.

#### Пример: создание кастомного стартер-пакета.

1. **Создай новый Maven проект**:

xml

Копировать код

`<groupId>com.example</groupId> <artifactId>custom-starter</artifactId> <version>1.0.0</version> <packaging>jar</packaging>`

2. **Добавь зависимости, которые будут частью стартера**:
    - Внутри стартер-проекта ты добавляешь зависимости, которые нужно предоставить другим проектам.

xml

Копировать код

`<dependencies>     <!-- Например, добавим Spring Data JPA -->     <dependency>         <groupId>org.springframework.boot</groupId>         <artifactId>spring-boot-starter-data-jpa</artifactId>     </dependency>      <!-- Добавим H2 базу данных для встроенного использования -->     <dependency>         <groupId>com.h2database</groupId>         <artifactId>h2</artifactId>     </dependency> </dependencies>`

3. **Создай `spring.factories` файл**:
    - Чтобы стартер автоматически подключался к Spring Boot, тебе нужно создать файл `spring.factories` внутри папки `META-INF`.
        
    - Этот файл указывает Spring Boot, какие авто-конфигурации загружать при старте приложения.
        

**Пример `spring.factories`**:

Копировать код

`org.springframework.boot.autoconfigure.EnableAutoConfiguration=\ com.example.MyCustomAutoConfiguration`

4. **Создай класс авто-конфигурации**:
    - В проекте стартера можно добавить класс авто-конфигурации, который будет автоматически подключаться, когда стартер используется в проекте.

java

Копировать код

`package com.example;  import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration;  @Configuration public class MyCustomAutoConfiguration {      @Bean     public MyService myService() {         return new MyService(); // Пример компонента, который добавляется через стартер     } }`

5. **Собери стартер в виде JAR файла**:
    - Используй команду `mvn clean install`, чтобы собрать проект в JAR файл.

### Использование созданного стартера:

1. После того как стартер собран, ты можешь использовать его в других проектах как зависимость.
    
2. Добавь зависимость на свой стартер в `pom.xml` другого проекта:
    

xml

Копировать код

`<dependency>     <groupId>com.example</groupId>     <artifactId>custom-starter</artifactId>     <version>1.0.0</version> </dependency>`

Когда этот стартер будет подключён в другом проекте, Spring Boot автоматически подключит все зависимости, указанные в стартере, а также конфигурации, которые были описаны в авто-конфигурационных классах.

### Итог:

- **Стартеры** в Spring Boot помогают легко и быстро подключать зависимости и конфигурации для различных технологий.
- Создание собственного стартера — это удобный способ собрать набор зависимостей и преднастроек, которые могут быть использованы повторно в других проектах.
- Основные шаги для создания кастомного стартера:
    - Создать Maven проект.
    - Добавить нужные зависимости в проект.
    - Добавить файл `spring.factories` для авто-конфигураций.
    - Собрать стартер и подключить его в других проектах.


# **Proxy**

В Spring используются два типа прокси для реализации аспектно-ориентированного программирования (AOP) и других динамических возможностей: **JDK Dynamic Proxy (динамический прокси на основе JDK)** и **CGLIB (Code Generation Library)**.

### 1. **JDK Dynamic Proxy** (Динамические прокси JDK)

**JDK Dynamic Proxy** — это механизм, встроенный в Java, который позволяет создавать прокси-объекты во время выполнения для интерфейсов. Прокси-объект перехватывает вызовы методов и может обрабатывать их по-своему, прежде чем передать управление реальной реализации.

#### Характеристики JDK Dynamic Proxy:

- **Работает только с интерфейсами**: JDK Dynamic Proxy может создавать прокси-объекты только для классов, реализующих интерфейсы. Если класс не реализует интерфейс, Spring не сможет использовать этот тип прокси.
- **Лёгкий и встроенный в JDK**: Прокси создаются без использования сторонних библиотек, так как механизм динамических прокси встроен в JDK.

#### Как это работает:

Когда ты применяешь аспекты или создаёшь бины с помощью Spring AOP, если целевой объект реализует интерфейс, Spring по умолчанию создаёт прокси с использованием JDK Dynamic Proxy. Этот прокси перехватывает вызовы методов, описанных в интерфейсе, и передаёт их объекту-реализации.

#### Пример:

```java
public interface MyService {
    void doSomething();
}

public class MyServiceImpl implements MyService {
    public void doSomething() {
        System.out.println("Executing MyServiceImpl");
    }
}

```

Если Spring применяет AOP для класса `MyServiceImpl`, используя JDK Dynamic Proxy, он создаст прокси для интерфейса `MyService`, который будет перехватывать вызовы методов.

### 2. **CGLIB (Code Generation Library)**

**CGLIB** — это сторонняя библиотека, используемая Spring для создания прокси-объектов с помощью **наследования**. В отличие от JDK Dynamic Proxy, который работает с интерфейсами, **CGLIB** создаёт прокси для самих классов, даже если они не реализуют интерфейс.

#### Характеристики CGLIB:

- **Работает с классами, не имеющими интерфейсов**: CGLIB может создавать прокси для классов, которые не реализуют интерфейсы.
- **Использует механизм наследования**: CGLIB создаёт подклассы от оригинальных классов и переопределяет их методы, чтобы перехватывать вызовы.
- **Более сложный, чем JDK Dynamic Proxy**: Поскольку CGLIB работает через механизм наследования, он требует больше ресурсов и может быть более сложен в настройке.

#### Когда используется CGLIB:

- Если класс, который ты пытаешься проксировать, не реализует интерфейс, Spring автоматически переключится на использование CGLIB для создания прокси-объекта.
- Если тебе нужно проксировать методы класса, которые не объявлены в интерфейсе, CGLIB — лучший выбор.

#### Пример:

```java
public class MyService {
    public void doSomething() {
        System.out.println("Executing MyService");
    }
}

```

В этом примере, если ты применяешь AOP к классу `MyService`, который не реализует интерфейс, Spring будет использовать CGLIB для создания прокси, потому что JDK Dynamic Proxy не сможет обработать класс без интерфейса.

### Сравнение JDK Dynamic Proxy и CGLIB:

|**Характеристика**|**JDK Dynamic Proxy**|**CGLIB**|
|---|---|---|
|**Механизм работы**|Работает с интерфейсами|Работает через наследование классов|
|**Необходимость интерфейса**|Требуется интерфейс|Интерфейс не требуется|
|**Производительность**|Лёгкий и встроенный в JDK|Медленнее из-за использования наследования|
|**Гибкость**|Ограничен интерфейсами|Подходит для любых классов|
|**Когда используется**|Когда класс реализует интерфейс|Когда класс не реализует интерфейс|

### Как Spring выбирает тип прокси?

1. Если класс реализует интерфейс, **Spring** по умолчанию будет использовать **JDK Dynamic Proxy**.
    
2. Если класс **не реализует интерфейс**, Spring автоматически переключится на **CGLIB** для создания прокси.
    
3. Ты можешь явно указать Spring использовать CGLIB для проксирования всех классов, независимо от того, реализуют ли они интерфейсы, добавив следующую настройку в файл `application.properties`:
    
    properties
    
    Копировать код
    
    `spring.aop.proxy-target-class=true`
    

### Когда стоит использовать JDK Proxy или CGLIB?

- **JDK Dynamic Proxy** лучше использовать, если твои классы уже реализуют интерфейсы, поскольку этот механизм проще и встроен в JDK, что делает его более лёгким.
- **CGLIB** используется, если у тебя нет интерфейсов, или если нужно проксировать конкретные методы класса, которые не объявлены в интерфейсе.

### Пример с использованием AOP:

Давай рассмотрим пример создания аспекта, который логирует вызовы методов сервиса:

```java
@Aspect
@Component
public class LoggingAspect {

    @Before("execution(* com.example.service.*.*(..))")
    public void logBeforeMethod(JoinPoint joinPoint) {
        System.out.println("Calling method: " + joinPoint.getSignature().getName());
    }
}


```

- **JDK Dynamic Proxy** будет использоваться, если классы сервиса реализуют интерфейс.
- **CGLIB** будет использоваться, если классы сервиса не реализуют интерфейсы.
# **JMX**

**JMX** (Java Management Extensions) — это стандартная технология Java для мониторинга и управления приложениями, объектами, устройствами и сервисами. JMX предоставляет интерфейс для получения данных о работе приложения и изменения его поведения во время выполнения.

#### Основные аспекты JMX:

- **MBeans (Managed Beans)**: Это объекты, которые управляют ресурсами или системами. Ты можешь зарегистрировать свои объекты как MBeans и получить к ним доступ через JMX для мониторинга или управления.
- **JMX Агент**: Это сервис, который управляет MBeans и обеспечивает доступ к ним через JMX-консоль или сторонние инструменты мониторинга (например, JConsole).
- **Использование JMX**: JMX позволяет отслеживать метрики приложения (например, загрузку процессора, использование памяти), управлять конфигурациями, перезапускать компоненты и даже выполнять удалённые команды.

```java
public interface HelloMBean {
    public void sayHello();
    public int add(int x, int y);
}

public class Hello implements HelloMBean {
    public void sayHello() {
        System.out.println("Hello, world!");
    }

    public int add(int x, int y) {
        return x + y;
    }
}

```

Ты можешь зарегистрировать этот MBean в JMX и затем управлять им через JMX-консоль или сторонний инструмент мониторинга.
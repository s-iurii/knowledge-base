

# @Transactional
отличная статья
https://habr.com/ru/companies/rosbank/articles/707378/

пару советов, как сократить накладные расходы при использовании @Transactional:

- Не стоит ставить @Transactional там, где будет происходить обработка только на сервисном уровне.
    
- Запуск метода, помеченного @Transactional, при определенных условиях может взять соединение из пула соединений с БД и не отпускать его до выхода из метода.
    
- Используйте propagation = NEVER там, где не хотите допустить использование транзакции (например, при параллельной разработке).
    
- Разносите логику работы с БД и внутреннюю логику сервиса по разным методам/сервисам, особенно походы во внешние системы или длительные вычислительные операции.


## Для грамотного управления транзакциями необходимо:​​

- определиться, нужны ли вам транзакции и/или блокировки в коде, возможно ли избавиться от конкуренции на этапе получения сообщений.
    
- правильно расставить в коде аннотацию @Transactional только там, где это необходимо;
    
- выбрать уровень изоляции, на котором вы будете работать с БД внутри одного проекта;
    
- разобраться, где нужна новая транзакция, а когда следует продолжать текущую;
    
- определиться с использованием блокировок и их типом, предусмотреть дедлоки;
    
- предусмотреть таймауты транзакций;
    
- оптимизировать код с целью уменьшения количества вызовов транзакционных методов и запросов в БД;
    
- предусмотреть идемпотентную обработку данных при повторах.

# Оптимистическая блокировка

### Как работает оптимистическая блокировка:

1. Когда объект читается из базы данных, вместе с ним сохраняется специальное поле (например, версия записи).
2. При попытке обновить объект проверяется, не изменилось ли это поле. Если версия объекта изменилась, это значит, что кто-то другой уже обновил этот объект.
3. Если версия не изменилась, данные сохраняются, а версия увеличивается.

### Аннотация `@Version`:

В Spring и JPA оптимистическая блокировка реализуется с помощью аннотации `@Version`. Эта аннотация указывает на специальное поле, которое используется для отслеживания версий сущности. Поле версии автоматически увеличивается каждый раз, когда сущность обновляется.

```java
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Version;

@Entity
public class Product {

    @Id
    private Long id;

    private String name;

    // Поле для оптимистической блокировки
    @Version
    private Integer version;

    // Геттеры и сеттеры
}

```

# Пессимистическая блокировка

аннотация `@Lock` используется в Spring Data JPA для управления блокировкой данных при выполнении запросов к базе данных. В отличие от оптимистической блокировки (`@Version`), `@Lock` реализует **пессимистическую блокировку**, которая блокирует данные на уровне базы данных, чтобы другие транзакции не могли изменять или читать заблокированные записи.

### Типы блокировок с `@Lock`:

Spring Data JPA поддерживает два типа пессимистической блокировки:

1. **`LockModeType.PESSIMISTIC_READ`**:
    - Устанавливает блокировку на чтение, что предотвращает другие транзакции от изменения заблокированной записи.
    - Транзакции могут читать запись, но не могут её изменять.
2. **`LockModeType.PESSIMISTIC_WRITE`**:
    - Устанавливает блокировку на запись, что предотвращает другие транзакции от чтения и изменения записи.
    - Транзакции не могут ни читать, ни изменять заблокированную запись, пока она не будет освобождена.
### Пример использования `@Lock`:

Предположим, что у нас есть сущность `Product`, и мы хотим использовать пессимистическую блокировку на уровне репозитория для методов чтения или изменения данных:

```java
import org.springframework.data.jpa.repository.Lock;
import org.springframework.data.jpa.repository.JpaRepository;
import javax.persistence.LockModeType;

public interface ProductRepository extends JpaRepository<Product, Long> {

    // Пример использования пессимистической блокировки на чтение
    @Lock(LockModeType.PESSIMISTIC_READ)
    Optional<Product> findById(Long id);
    
    // Пример использования пессимистической блокировки на запись
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    Product save(Product product);
}
```

# timeout 
таймауты при использовании транзакций могут возникать, если транзакция длится слишком долго и превышает установленное время выполнения. Это может привести к тому, что транзакция будет прервана и откатится.

В Spring ты можешь контролировать время выполнения транзакций с помощью свойства **`timeout`** в аннотации `@Transactional`.
```java
@Transactional(timeout = 5) // Таймаут 5 секунд
public void someTransactionalMethod() {
    // Логика метода
}

```

### Как это работает:

- В данном примере, если выполнение метода `someTransactionalMethod()` займет больше 5 секунд, транзакция будет прервана, и все изменения, сделанные в рамках этой транзакции, будут откатаны.

### Причины возникновения таймаутов:

1. **Длительные операции**: Запросы к базе данных или внешним сервисам могут занимать больше времени, чем установлено в таймауте.
2. **Блокировки на уровне базы данных**: Если используются пессимистические блокировки (`@Lock`) или в БД происходят долгие транзакции, это может задерживать выполнение текущей транзакции.
3. **Проблемы с производительностью**: Долгие операции в коде, например, сложные вычисления или неэффективные запросы к базе данных.

### Как предотвратить проблемы с таймаутами:

1. **Анализируй запросы**: Проверь, не задерживают ли долгие запросы или блокировки выполнение транзакции.
2. **Устанавливай разумные таймауты**: Настрой таймаут на основе ожидаемой продолжительности операций. Например, если операция требует много времени, увеличь таймаут.
3. **Используй асинхронность**: Для долгих операций можно использовать асинхронные вызовы, чтобы не блокировать основную транзакцию.
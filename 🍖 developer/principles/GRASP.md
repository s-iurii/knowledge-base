
**GRASP (General Responsibility Assignment Software Patterns)** — это набор принципов и паттернов, которые помогают разработчикам грамотно распределять обязанности и ответственность между классами и объектами в объектно-ориентированных системах. Принципы GRASP были предложены Крейгом Ларманом (Craig Larman) как часть методологии объектно-ориентированного анализа и проектирования.

GRASP помогает отвечать на вопрос: **"Какой класс или объект должен выполнять ту или иную задачу?"** Эти принципы помогают структурировать код, улучшать читаемость и поддерживаемость, а также делать архитектуру системы более гибкой.

### Основные принципы GRASP:

1. **Information Expert (Информационный эксперт)**
2. **Creator (Создатель)**
3. **Controller (Контроллер)**
4. **Low Coupling (Низкая связанность)**
5. **High Cohesion (Высокая связность)**
6. **Polymorphism (Полиморфизм)**
7. **Pure Fabrication (Чистая фабрикация)**
8. **Indirection (Посредничество)**
9. **Protected Variations (Защита от вариаций)**

### Давай рассмотрим каждый принцип подробнее:

---

#### 1. **Information Expert (Информационный эксперт)**

**Суть**:

- Принцип гласит, что ответственность за выполнение задачи или принятие решения должна быть назначена тому объекту, который владеет необходимой информацией для этого.

**Пример**:

- Если у нас есть система заказа продуктов, то объект `Order` должен быть ответственен за подсчёт общей стоимости заказа, так как он "знает" о всех товарах и их количестве.

java

Копировать код

`public class Order {     private List<OrderItem> items;      public double calculateTotal() {         double total = 0;         for (OrderItem item : items) {             total += item.getPrice();         }         return total;     } }`

---

#### 2. **Creator (Создатель)**

**Суть**:

- Принцип указывает, что объект должен быть ответственен за создание других объектов, если:
    - Он содержит их.
    - Он использует их.
    - Он агрегирует их.
    - Или у него есть необходимая информация для их создания.

**Пример**:

- Класс `Order` может быть ответственен за создание объектов `OrderItem`, так как он управляет элементами заказа.

java

Копировать код

`public class Order {     private List<OrderItem> items = new ArrayList<>();      public void addItem(Product product, int quantity) {         OrderItem item = new OrderItem(product, quantity);         items.add(item);     } }`

---

#### 3. **Controller (Контроллер)**

**Суть**:

- Контроллер — это объект, который управляет обработкой запросов от пользователя. Это объект, который принимает запрос, а затем делегирует выполнение другим объектам. Обычно это верхний уровень логики, который управляет жизненным циклом взаимодействий.

**Пример**:

- В веб-приложении контроллер принимает запросы от пользователя и передаёт их бизнес-логике.

java

Копировать код

`public class OrderController {     private OrderService orderService;      public void createOrder(User user, List<Product> products) {         orderService.createOrder(user, products);     } }`

---

#### 4. **Low Coupling (Низкая связанность)**

**Суть**:

- Принцип низкой связанности гласит, что классы должны иметь как можно меньше зависимостей от других классов. Это улучшает гибкость системы и упрощает её поддержку, так как изменение одного компонента не приведёт к необходимости изменения других.

**Пример**:

- Вместо того чтобы класс `Order` напрямую зависел от класса `Database`, лучше инкапсулировать доступ к базе данных через интерфейс или абстракцию.

java

Копировать код

`public class Order {     private OrderRepository repository;      public Order(OrderRepository repository) {         this.repository = repository;     }      public void save() {         repository.save(this);     } }`

---

#### 5. **High Cohesion (Высокая связность)**

**Суть**:

- Принцип высокой связности указывает на то, что ответственность класса или модуля должна быть сфокусирована на одной задаче. Это улучшает ясность и поддерживаемость кода.

**Пример**:

- Класс `Order` отвечает только за логику, связанную с заказами, и не должен включать логику, связанную с оплатой или доставкой.

java

Копировать код

`public class Order {     private List<OrderItem> items;     private User user;      public void addItem(OrderItem item) {         items.add(item);     }      public double getTotalPrice() {         // Логика подсчёта стоимости     } }`

---

#### 6. **Polymorphism (Полиморфизм)**

**Суть**:

- Принцип полиморфизма подразумевает использование интерфейсов или абстрактных классов для определения операций, которые могут изменяться в зависимости от конкретной реализации.

**Пример**:

- Если у нас есть несколько типов оплаты (кредитная карта, PayPal), мы можем создать интерфейс `Payment` и реализовать его разными способами.

java

Копировать код

`public interface Payment {     void processPayment(double amount); }  public class CreditCardPayment implements Payment {     public void processPayment(double amount) {         // Логика оплаты через кредитную карту     } }  public class PayPalPayment implements Payment {     public void processPayment(double amount) {         // Логика оплаты через PayPal     } }`

---

#### 7. **Pure Fabrication (Чистая фабрикация)**

**Суть**:

- Принцип "Чистая фабрикация" подразумевает создание искусственного объекта (класса), который не отражает реального объекта предметной области, но необходим для уменьшения связности и повышения повторного использования кода.

**Пример**:

- Вместо того чтобы логику сохранения объектов хранить в классе сущности, можно создать отдельный класс `Repository`, который будет отвечать за доступ к данным.

java

Копировать код

`public class OrderRepository {     public void save(Order order) {         // Логика сохранения заказа в базе данных     } }`

---

#### 8. **Indirection (Посредничество)**

**Суть**:

- Этот принцип использует посредников для обеспечения слабой связанности между классами. Посредник направляет запросы от одного класса к другому, изолируя их друг от друга.

**Пример**:

- В проекте можно использовать паттерн `Service`, который будет посредником между контроллером и логикой работы с базой данных.

java

Копировать код

`public class OrderService {     private OrderRepository repository;      public void createOrder(User user, List<Product> products) {         Order order = new Order(user, products);         repository.save(order);     } }`

---

#### 9. **Protected Variations (Защита от вариаций)**

**Суть**:

- Принцип защиты от вариаций предполагает создание стабильных интерфейсов, которые защищают систему от изменений в её реализации. Это делается через использование абстракций и интерфейсов.

**Пример**:

- Использование интерфейсов или абстрактных классов для создания API, которые не зависят от конкретных реализаций, помогает защитить систему от изменений.

java

Копировать код

`public interface NotificationService {     void sendNotification(String message); }  public class EmailNotificationService implements NotificationService {     public void sendNotification(String message) {         // Отправка сообщения по email     } }  public class SMSNotificationService implements NotificationService {     public void sendNotification(String message) {         // Отправка SMS сообщения     } }`

---

### Заключение:

Принципы GRASP помогают разработчикам грамотно распределять обязанности между классами и объектами. Основная идея GRASP заключается в том, чтобы сделать архитектуру системы гибкой, легко поддерживаемой и расширяемой, снижая связанность между компонентами и повышая их связность.
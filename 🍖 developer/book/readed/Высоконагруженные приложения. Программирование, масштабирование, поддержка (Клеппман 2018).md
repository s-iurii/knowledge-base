
ccылки:
https://github.com/ept/ddia-references

# Надежность
## сбои
Аппаратные сбои
Программные ошибки
Человеческий фактор

# Масштабируемость

Время ожидания и время отклика

Термины «время ожидания» (latency) и «время отклика» (response time) часто используются как синонимы, хотя это не одно и то же. Время откли- ка — то, что видит клиент: помимо фактического времени обработки запроса (время обслуживания, service time), оно включает задержки при передаче информации по сети и задержки сообщений в очереди. Время ожидания — длительность ожидания запросом обработки, то есть время, на протяжении которого он ожидает обслуживания [17].


## ID
Преимущество идентификаторов состоит в том, что в силу отсутствия какого-либо смысла их для людей нет необходимости менять их в каких-либо случаях: ID спо- собен оставаться тем же самым даже при изменении информации, на которую он указывает. А все значимое для людей может понадобиться поменять в будущем — и если эта информация дублируется, то придется обновлять все имеющиеся копии. Данное обстоятельство приводит к избыточности записи и риску несоответствий (когда одни копии информации обновлены, а другие — нет). Идея исключения подобного дублирования лежит в основе нормализации баз данных1.


# Индексирование
[[index]]

## LSM-дерева
Изначально эта индексная структура была описана Патриком О’Нилом и др. под названием журналированного дерева слияния (Log-Structured Merge-Tree, LSM-Tree) [10], на основе более ранней работы, посвященной журналированным фай- ловым системам [11]. Подсистемы хранения, основанные на принципе слияния и уплот- нения отсортированных файлов, часто называются LSM-подсистемами хранения.

Несмотря на множество нюансов, основная идея LSM-деревьев — применение каскада SS-таблиц, объединяемых в фоновом режиме, — проста и эффективна. Она хорошо работает даже в случае, когда размер набора данных значительно превышает доступный объем оперативной памяти. То, что данные хранятся в отсортированном виде, дает возможность эффективно выполнять запросы по диапазонам (просмотр всех ключей между установленными минимальным и максимальным значениями), а поскольку записи на диск осуществляются по- следовательно, LSM-дерево способно поддерживать весьма высокую пропускную способность по записи.
### +
скорость, с которой база записывает данные на диск.
особенно для магнитных жестких дисков, на которых последовательные операции записи (способствует переуплотнени, дефрагментация, которая происходит в фоне, также меньше дискового пространства)работают намного быстрее, чем произвольные.
### -
работа по уплотнению в фоне может замедлять работу других операций.
при случае когда обьемы записи велеки и уплотнение не успевает 
снизится скорость и пространство может закончится.
 журналированных подсистемах хранения может быть несколько копий одного ключа в разных сегментах. тружнее обеспецить транзакционность.
## B-деревья
### +
Преимущество B-деревьев состоит в том, что каждый ключ встречается в индексе только в одном месте, в то время как в журналированных подсистемах хранения может быть несколько копий одного ключа в разных сегментах. Эта особенность функционирования делает B-деревья привлекательными для тех баз данных, которые стремятся обеспечить сильно выраженную транзакционность:
### -
Подсистемы хранения на основе B-деревьев оставляют некоторое пространство на диске незадействованным в силу фрагмента- ции: когда страница разбивается на части или строка не помещается на существу- ющую страницу, некий объем пространства на странице остается незадействованным.

## PostGIS

При просмотре пользователем ресторанов на карте сайту необходимо найти все рестораны, расположенные внутри текущей прямоугольной области на карте. Для этого необходим двумерный запрос по диапазону вот такого вида:

SELECT * FROM restaurants WHERE latitude  > 51.4946 AND latitude  < 51.5079
                          AND longitude > -0.1162 AND longitude < -0.1004;

Стандартный индекс на основе B-дерева или LSM-дерева не сможет обеспечить эффективное выполнение подобного запроса: он сумеет выдать или все рестораны в определенном диапазоне широт (но с произвольной долготой), или все рестораны в определенном диапазоне долгот (но в любой точке между Северным и Южным полюсами), но не сможет выдать и то и другое сразу.

Один из вариантов решения этого проблемы — преобразовать двумерное место- положение в одно число с помощью заполняющей пространство кривой, после чего воспользоваться обычным индексом на основе B-дерева [34]. Но чаще применяются специализированные пространственные индексы, такие как R-деревья. Напри- мер, в PostGIS геопространственные индексы реализуются в виде R-деревьев благодаря функции Generalized Search Tree (обобщенное дерево поиска) СУБД PostgreSQL [35]. У нас недостаточно места, чтобы описывать в этой книге R-деревья во всех подробностях, но им посвящено множество литературы.

## Кластеризованным индексом
Хранение значений в индексах
Компромисс между кластеризованным индексом (хранением всех ключей в ин- дексе) и некластеризованным (хранением в индексе только ссылок на данные) известен под названием охватывающего индекса (covering index) или индекса с включенными столбцами (index with included columns). При этом в индексе хра- нится только часть столбцов таблицы [33]. Благодаря такому обстоятельству по- является возможность отвечать на некоторые запросы с помощью только одного индекса (и тогда говорят, что индекс охватывает запрос)

## Составные индексы
Наиболее распространенный тип составных индексов — сцепленный индекс (concatenated index), который просто объединяет несколько полей в один ключ, присоединяя один столбец к другому (в описании индекса указывается, в каком порядке сцепляются поля).